# 写作辅助模块功能完善方案

## 1. 三阶段生成机制

### 1.1 数据库结构扩展

#### A. 扩展 ArticleGenerationResult 表
```sql
-- 新增字段
ALTER TABLE ArticleGenerationResult ADD COLUMN generationStage TEXT DEFAULT 'final'; -- 'outline', 'draft', 'final'
ALTER TABLE ArticleGenerationResult ADD COLUMN outlineContent TEXT; -- 大纲内容
ALTER TABLE ArticleGenerationResult ADD COLUMN draftContent TEXT; -- 初稿内容
ALTER TABLE ArticleGenerationResult ADD COLUMN finalContent TEXT; -- 最终内容（原 generatedContent）
ALTER TABLE ArticleGenerationResult ADD COLUMN selfReviewNotes TEXT; -- 自查优化说明
ALTER TABLE ArticleGenerationResult ADD COLUMN stageTokens TEXT; -- 各阶段token消耗 JSON格式

-- 用户反馈字段
ALTER TABLE ArticleGenerationResult ADD COLUMN userRating INTEGER; -- 1-5评分
ALTER TABLE ArticleGenerationResult ADD COLUMN userFeedback TEXT; -- 具体反馈文本
ALTER TABLE ArticleGenerationResult ADD COLUMN feedbackTags TEXT; -- JSON格式的反馈标签
ALTER TABLE ArticleGenerationResult ADD COLUMN adjustmentTarget TEXT; -- 'overview' | 'profile'
ALTER TABLE ArticleGenerationResult ADD COLUMN isImproved BOOLEAN DEFAULT FALSE; -- 是否已改进
```

#### B. 新增反馈模式表
```sql
CREATE TABLE FeedbackPattern (
  id TEXT PRIMARY KEY,
  username TEXT NOT NULL,
  contentType TEXT NOT NULL,
  feedbackType TEXT, -- 'negative', 'positive', 'suggestion'
  pattern TEXT, -- 具体问题模式，如"太书面化"、"表达不够口语化"
  frequency INTEGER DEFAULT 1, -- 出现频次
  lastOccurred DATETIME,
  isResolved BOOLEAN DEFAULT FALSE,
  createdAt DATETIME DEFAULT CURRENT_TIMESTAMP,
  updatedAt DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_feedback_pattern_user ON FeedbackPattern(username, contentType);
CREATE INDEX idx_feedback_pattern_type ON FeedbackPattern(feedbackType, isResolved);
```

### 1.2 三阶段生成流程

#### 阶段1: 内容类型化大纲生成 (Outline)

##### A. 内容类型大纲模板
```typescript
interface OutlineTemplate {
  contentType: string;
  category: string;
  structure: OutlineSection[];
  tone: string;
  keyElements: string[];
  avoidElements?: string[];
}

interface OutlineSection {
  name: string;
  purpose: string;
  suggestedLength?: string;
  keyPoints: string[];
  optional?: boolean;
}

// 内容类型大纲模板配置
export const OUTLINE_TEMPLATES: Record<TweetType, OutlineTemplate> = {
  // 内容导向类
  '新闻/事件': {
    contentType: '新闻/事件',
    category: '内容导向类',
    tone: 'objective',
    keyElements: ['时效性', '准确性', '客观性'],
    structure: [
      {
        name: '核心事件',
        purpose: '简明扼要地描述发生了什么',
        suggestedLength: '1-2句',
        keyPoints: ['时间要素', '关键当事人', '核心事实']
      },
      {
        name: '背景信息',
        purpose: '提供必要的上下文信息',
        keyPoints: ['相关背景', '影响范围', '重要性说明']
      },
      {
        name: '后续发展',
        purpose: '说明可能的影响或后续动态',
        keyPoints: ['潜在影响', '关注要点'],
        optional: true
      }
    ]
  },

  '研究/数据': {
    contentType: '研究/数据',
    category: '内容导向类',
    tone: 'analytical',
    keyElements: ['数据准确', '分析客观', '结论可信'],
    structure: [
      {
        name: '研究背景',
        purpose: '介绍研究的背景和重要性',
        keyPoints: ['研究问题', '数据来源', '研究意义']
      },
      {
        name: '核心发现',
        purpose: '展示关键数据和研究结果',
        keyPoints: ['关键数据', '统计结果', '趋势变化']
      },
      {
        name: '深度分析',
        purpose: '解读数据背后的原因和意义',
        keyPoints: ['原因分析', '影响评估', '对比参照']
      },
      {
        name: '结论启示',
        purpose: '总结研究结论和实际应用',
        keyPoints: ['核心结论', '实际意义', '未来预测'],
        optional: true
      }
    ]
  },

  '科普': {
    contentType: '科普',
    category: '内容导向类',
    tone: 'educational',
    keyElements: ['通俗易懂', '逻辑清晰', '生动有趣'],
    structure: [
      {
        name: '引入问题',
        purpose: '引出要科普的概念或现象',
        keyPoints: ['日常场景', '引发好奇', '提出问题']
      },
      {
        name: '核心解释',
        purpose: '用通俗语言解释核心概念',
        keyPoints: ['基本原理', '简单类比', '关键机制']
      },
      {
        name: '实例验证',
        purpose: '通过具体例子加深理解',
        keyPoints: ['生活实例', '应用场景', '验证说明']
      },
      {
        name: '总结延伸',
        purpose: '总结要点并引发进一步思考',
        keyPoints: ['关键总结', '延伸思考'],
        optional: true
      }
    ]
  },

  '教程/技巧': {
    contentType: '教程/技巧',
    category: '内容导向类',
    tone: 'instructional',
    keyElements: ['步骤清晰', '实用性强', '易于操作'],
    structure: [
      {
        name: '问题场景',
        purpose: '描述要解决的问题或需求',
        keyPoints: ['具体场景', '痛点描述', '解决必要性']
      },
      {
        name: '解决方案',
        purpose: '提供具体的操作步骤或方法',
        keyPoints: ['步骤分解', '关键要点', '注意事项']
      },
      {
        name: '效果展示',
        purpose: '说明预期效果和验证方法',
        keyPoints: ['预期结果', '成功标志', '常见问题']
      },
      {
        name: '进阶提升',
        purpose: '提供更深入的技巧或相关建议',
        keyPoints: ['进阶技巧', '相关工具', '延伸学习'],
        optional: true
      }
    ]
  },

  // 观点表达类
  '时事评论': {
    contentType: '时事评论',
    category: '观点表达类',
    tone: 'opinionated',
    keyElements: ['观点鲜明', '逻辑严密', '有理有据'],
    structure: [
      {
        name: '事件概述',
        purpose: '简要介绍评论的事件或现象',
        keyPoints: ['关键事实', '争议焦点', '社会关注度']
      },
      {
        name: '个人观点',
        purpose: '明确表达自己的立场和看法',
        keyPoints: ['核心观点', '判断依据', '价值立场']
      },
      {
        name: '论证分析',
        purpose: '用逻辑和事实支撑观点',
        keyPoints: ['逻辑推理', '事实支撑', '反面论证']
      },
      {
        name: '总结呼吁',
        purpose: '总结观点并提出建议或呼吁',
        keyPoints: ['观点总结', '行动建议', '未来展望'],
        optional: true
      }
    ]
  },

  '洞见/观点/观察': {
    contentType: '洞见/观点/观察',
    category: '观点表达类',
    tone: 'reflective',
    keyElements: ['深度思考', '独特视角', '启发性'],
    structure: [
      {
        name: '现象观察',
        purpose: '描述观察到的现象或趋势',
        keyPoints: ['具体现象', '观察细节', '普遍性']
      },
      {
        name: '深层洞察',
        purpose: '提出独特的见解和思考',
        keyPoints: ['本质分析', '内在逻辑', '深层原因']
      },
      {
        name: '启发思考',
        purpose: '引发读者进一步的思考',
        keyPoints: ['思考方向', '相关联想', '价值意义']
      },
      {
        name: '观点延伸',
        purpose: '将洞察扩展到更广阔的层面',
        keyPoints: ['普遍规律', '类比思考', '未来趋势'],
        optional: true
      }
    ]
  },

  '价值观表达': {
    contentType: '价值观表达',
    category: '观点表达类',
    tone: 'philosophical',
    keyElements: ['理念明确', '价值坚持', '人生智慧'],
    structure: [
      {
        name: '价值触发',
        purpose: '描述引发价值观思考的事件或情境',
        keyPoints: ['触发事件', '内心感受', '价值冲突']
      },
      {
        name: '理念阐述',
        purpose: '明确表达自己的价值观和人生理念',
        keyPoints: ['核心理念', '价值标准', '人生原则']
      },
      {
        name: '意义诠释',
        purpose: '解释这种价值观的意义和重要性',
        keyPoints: ['价值意义', '人生指导', '选择标准']
      },
      {
        name: '行动体现',
        purpose: '说明如何在实际生活中践行这种价值观',
        keyPoints: ['具体行动', '生活体现', '坚持方式'],
        optional: true
      }
    ]
  },

  // 生活情感类
  '日常生活': {
    contentType: '日常生活',
    category: '生活情感类',
    tone: 'casual',
    keyElements: ['真实自然', '生活化', '轻松愉快'],
    avoidElements: ['说教', '复杂论证', '专业术语'],
    structure: [
      {
        name: '生活场景',
        purpose: '描述具体的生活情境或经历',
        keyPoints: ['时间地点', '具体活动', '人物互动']
      },
      {
        name: '感受分享',
        purpose: '表达个人的感受和体验',
        keyPoints: ['直接感受', '情绪状态', '有趣细节']
      },
      {
        name: '简单总结',
        purpose: '轻松结尾，可能引发共鸣',
        keyPoints: ['简单感慨', '生活感悟', '轻松调侃'],
        optional: true
      }
    ]
  },

  '心情表达': {
    contentType: '心情表达',
    category: '生活情感类',
    tone: 'emotional',
    keyElements: ['情感真挚', '表达直接', '引发共鸣'],
    structure: [
      {
        name: '情绪状态',
        purpose: '直接表达当前的心情或情感',
        keyPoints: ['情绪词汇', '强度表达', '情感色彩']
      },
      {
        name: '原因背景',
        purpose: '说明产生这种情绪的原因',
        keyPoints: ['触发事件', '具体情境', '个人经历']
      },
      {
        name: '情感共鸣',
        purpose: '寻求理解或引发读者共鸣',
        keyPoints: ['通用经历', '情感连接', '互动邀请'],
        optional: true
      }
    ]
  },

  '个人经历/成长': {
    contentType: '个人经历/成长',
    category: '生活情感类',
    tone: 'reflective',
    keyElements: ['真实经历', '成长感悟', '人生启示'],
    structure: [
      {
        name: '经历描述',
        purpose: '详细描述具体的个人经历',
        keyPoints: ['事件经过', '关键转折', '当时感受']
      },
      {
        name: '成长感悟',
        purpose: '分享从经历中获得的感悟和成长',
        keyPoints: ['重要领悟', '思维变化', '能力提升']
      },
      {
        name: '价值启示',
        purpose: '总结经历带来的人生启示',
        keyPoints: ['人生道理', '价值发现', '未来指导']
      },
      {
        name: '经验分享',
        purpose: '为他人提供可借鉴的经验',
        keyPoints: ['实用建议', '避坑指南', '成长路径'],
        optional: true
      }
    ]
  },

  // 互动传播类
  '资源分享': {
    contentType: '资源分享',
    category: '互动传播类',
    tone: 'sharing',
    keyElements: ['实用价值', '使用体验', '推荐理由'],
    structure: [
      {
        name: '资源介绍',
        purpose: '简要介绍要分享的资源',
        keyPoints: ['资源类型', '基本信息', '获取方式']
      },
      {
        name: '使用体验',
        purpose: '分享个人使用感受和效果',
        keyPoints: ['使用场景', '实际效果', '优缺点评价']
      },
      {
        name: '推荐建议',
        purpose: '给出使用建议和推荐理由',
        keyPoints: ['适用人群', '使用技巧', '推荐指数']
      },
      {
        name: '延伸推荐',
        purpose: '推荐相关的其他优质资源',
        keyPoints: ['类似资源', '配套工具', '进阶选择'],
        optional: true
      }
    ]
  },

  '互动话题': {
    contentType: '互动话题',
    category: '互动传播类',
    tone: 'interactive',
    keyElements: ['话题性强', '引发讨论', '互动友好'],
    structure: [
      {
        name: '话题引入',
        purpose: '提出有趣或有争议的话题',
        keyPoints: ['话题背景', '引发点', '关注度']
      },
      {
        name: '观点展示',
        purpose: '展示不同的观点或选择',
        keyPoints: ['多元观点', '利弊分析', '选择困境']
      },
      {
        name: '互动邀请',
        purpose: '明确邀请读者参与讨论',
        keyPoints: ['问题抛出', '投票选择', '经验征集']
      },
      {
        name: '讨论引导',
        purpose: '引导讨论向更深层次发展',
        keyPoints: ['深度问题', '思考角度', '价值探讨'],
        optional: true
      }
    ]
  },

  '搞笑': {
    contentType: '搞笑',
    category: '互动传播类',
    tone: 'humorous',
    keyElements: ['幽默感', '轻松有趣', '引发笑点'],
    avoidElements: ['严肃说教', '复杂逻辑', '沉重话题'],
    structure: [
      {
        name: '设置铺垫',
        purpose: '营造幽默的情境或背景',
        keyPoints: ['场景设定', '人物关系', '预期营造']
      },
      {
        name: '笑点爆发',
        purpose: '制造反转或幽默的高潮',
        keyPoints: ['意外反转', '夸张表现', '对比效果']
      },
      {
        name: '余韵延续',
        purpose: '延续幽默效果或引发互动',
        keyPoints: ['幽默总结', '互动邀请', '后续调侃'],
        optional: true
      }
    ]
  }
};
```

##### B. 智能大纲生成器
```typescript
export class ContentTypeOutlineGenerator {

  async generateOutline(task: ArticleGenerationTask): Promise<string> {
    const contentType = task.contentType as TweetType;
    const template = OUTLINE_TEMPLATES[contentType];

    if (!template) {
      return await this.generateGenericOutline(task);
    }

    const prompt = this.buildTypeSpecificPrompt(task, template);
    const config = await WritingAssistantConfigLoader.getAnalysisConfig();
    const aiService = AIServiceFactory.createService({
      provider: config.provider,
      model: config.model,
      apiKey: config.apiKey,
      baseURL: config.baseURL
    });

    return await aiService.generateText(prompt);
  }

  private buildTypeSpecificPrompt(task: ArticleGenerationTask, template: OutlineTemplate): string {
    let prompt = `请为"${template.contentType}"类型的内容生成详细大纲：

主题：${task.topic}
平台：${task.platform.name}
${task.platform.wordCount ? `字数要求：${task.platform.wordCount}` : ''}

内容类型特征：
- 类别：${template.category}
- 语调：${template.tone}
- 核心要素：${template.keyElements.join('、')}`;

    if (template.avoidElements) {
      prompt += `\n- 避免元素：${template.avoidElements.join('、')}`;
    }

    prompt += `\n\n请按照以下结构框架生成大纲：\n`;

    template.structure.forEach((section, index) => {
      prompt += `\n${index + 1}. ${section.name}${section.optional ? '（可选）' : ''}
目的：${section.purpose}
${section.suggestedLength ? `建议长度：${section.suggestedLength}` : ''}
关键要点：${section.keyPoints.join('、')}`;
    });

    prompt += `\n\n生成要求：
1. 严格按照${template.contentType}类型的特点组织内容
2. 确保大纲逻辑清晰、层次分明
3. 每个部分都要有具体的内容要点
4. 保持${template.tone}的语调特征
5. 不要生成具体的正文内容，只生成结构化的大纲

请直接输出大纲内容：`;

    return prompt;
  }
}

// 修改原有的 generateOutline 函数
async function generateOutline(task: ArticleGenerationTask): Promise<string> {
  const generator = new ContentTypeOutlineGenerator();
  const validator = new OutlineValidator();

  // 生成大纲
  let outline = await generator.generateOutline(task);

  // 验证大纲质量
  if (task.contentType) {
    const validation = validator.validateOutline(outline, task.contentType as TweetType);

    if (!validation.isValid && validation.warnings.length > 0) {
      console.log(`大纲验证警告: ${validation.warnings.join(', ')}`);

      // 如果有严重问题，尝试重新生成
      if (validation.warnings.length >= 2) {
        console.log('尝试重新生成大纲...');
        outline = await generator.generateOutline(task);
      }
    }
  }

  return outline;
}
```

##### C. 大纲质量验证器
```typescript
export class OutlineValidator {

  validateOutline(outline: string, contentType: TweetType): ValidationResult {
    const template = OUTLINE_TEMPLATES[contentType];
    if (!template) {
      return { isValid: true, warnings: [] };
    }

    const warnings: string[] = [];

    // 检查是否包含必要的结构元素
    const requiredSections = template.structure.filter(s => !s.optional);
    requiredSections.forEach(section => {
      if (!this.containsSection(outline, section)) {
        warnings.push(`缺少必要部分：${section.name}`);
      }
    });

    // 检查是否包含应避免的元素
    if (template.avoidElements) {
      template.avoidElements.forEach(element => {
        if (outline.toLowerCase().includes(element.toLowerCase())) {
          warnings.push(`包含应避免的元素：${element}`);
        }
      });
    }

    return {
      isValid: warnings.length === 0,
      warnings,
      suggestions: this.generateSuggestions(warnings, template)
    };
  }

  private containsSection(outline: string, section: OutlineSection): boolean {
    const sectionKeywords = [section.name, ...section.keyPoints];
    return sectionKeywords.some(keyword =>
      outline.toLowerCase().includes(keyword.toLowerCase())
    );
  }
}

interface ValidationResult {
  isValid: boolean;
  warnings: string[];
  suggestions?: string[];
}
```

#### 阶段2: 初稿扩展 (Draft)
```typescript
async function generateDraft(outline: string, task: ArticleGenerationTask): Promise<string> {
  const prompt = `基于以下大纲，撰写完整的初稿：

大纲：
${outline}

主题：${task.topic}
平台要求：${task.platform.name}
${task.platform.wordCount ? `字数要求：${task.platform.wordCount}` : ''}

${task.username ? await buildDetailedStylePrompt(task.username, task.contentType) : ''}

撰写要求：
1. 严格按照大纲结构展开
2. 保持内容的逻辑性和连贯性
3. 融入个人写作风格
4. 确保内容充实且有价值

请撰写完整的文章内容：`;

  return await callAI(prompt);
}
```

#### 阶段3: 自查优化 (Final)
```typescript
async function selfReviewAndOptimize(draft: string, task: ArticleGenerationTask): Promise<{content: string, reviewNotes: string}> {
  const prompt = `请对以下初稿进行自查和优化：

初稿内容：
${draft}

原始要求：
- 主题：${task.topic}
- 平台：${task.platform.name}
- 字数要求：${task.platform.wordCount || '适中'}

${task.username ? `用户写作风格要求：${await getStyleSummary(task.username, task.contentType)}` : ''}

请从以下维度进行检查和优化：
1. 内容完整性：是否充分回应主题
2. 逻辑结构：段落间的逻辑关系是否清晰
3. 语言表达：是否符合平台特色和用户风格
4. 信息密度：内容是否充实有价值
5. 读者体验：是否易读且有吸引力

返回JSON格式：
{
  "optimizedContent": "优化后的完整内容",
  "reviewNotes": "具体优化说明，包括修改的地方和理由"
}`;

  const result = await callAI(prompt);
  const parsed = JSON.parse(result);
  return {
    content: parsed.optimizedContent,
    reviewNotes: parsed.reviewNotes
  };
}
```

### 1.3 三阶段生成主流程
```typescript
async function processThreeStageGeneration(taskId: string): Promise<void> {
  try {
    await updateTaskStatus(taskId, "processing");

    const task = await getTaskWithRelations(taskId);

    // 阶段1：大纲生成
    console.log(`[${taskId}] 开始生成大纲...`);
    const outline = await generateOutline(task);

    await saveGenerationResult(taskId, {
      stage: 'outline',
      content: outline,
      tokens: await calculateTokens(outline)
    });

    // 阶段2：初稿扩展
    console.log(`[${taskId}] 基于大纲生成初稿...`);
    const draft = await generateDraft(outline, task);

    await saveGenerationResult(taskId, {
      stage: 'draft',
      content: draft,
      tokens: await calculateTokens(draft)
    });

    // 阶段3：自查优化
    console.log(`[${taskId}] 进行自查优化...`);
    const { content: finalContent, reviewNotes } = await selfReviewAndOptimize(draft, task);

    await saveGenerationResult(taskId, {
      stage: 'final',
      content: finalContent,
      reviewNotes,
      tokens: await calculateTokens(finalContent)
    });

    await updateTaskStatus(taskId, "completed");
    console.log(`[${taskId}] 三阶段生成完成`);

  } catch (error) {
    console.error(`三阶段生成失败 (任务ID: ${taskId}):`, error);
    await updateTaskStatus(taskId, "failed", error.message);
  }
}
```

## 2. 用户反馈双层调整机制

### 2.1 前端反馈界面组件

#### A. 反馈收集表单
```tsx
interface FeedbackFormProps {
  resultId: string;
  username: string;
  contentType: string;
  generatedContent: string;
  stage: 'outline' | 'draft' | 'final';
}

function FeedbackForm({ resultId, username, contentType, generatedContent, stage }: FeedbackFormProps) {
  const [rating, setRating] = useState(0);
  const [feedbackText, setFeedbackText] = useState('');
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [adjustmentTarget, setAdjustmentTarget] = useState<'overview' | 'profile'>('profile');

  const commonFeedbackTags = [
    '太书面化', '不够口语化', '语调过于严肃', '缺乏个人特色',
    '开头过于突兀', '结尾不够有力', '逻辑不够清晰', '内容过于浅显',
    '专业术语过多', '表达过于复杂', '语言过于平淡', '缺乏互动感'
  ];

  return (
    <Card className="feedback-container">
      <CardHeader>
        <CardTitle>内容反馈 - {stage === 'final' ? '最终版' : stage === 'draft' ? '初稿' : '大纲'}</CardTitle>
      </CardHeader>

      <CardContent className="space-y-6">
        {/* 评分组件 */}
        <div>
          <Label>整体满意度</Label>
          <StarRating value={rating} onChange={setRating} />
        </div>

        {/* 快速标签选择 */}
        <div>
          <Label>常见问题（可多选）</Label>
          <div className="flex flex-wrap gap-2 mt-2">
            {commonFeedbackTags.map(tag => (
              <Badge
                key={tag}
                variant={selectedTags.includes(tag) ? "default" : "outline"}
                className="cursor-pointer"
                onClick={() => toggleTag(tag)}
              >
                {tag}
              </Badge>
            ))}
          </div>
        </div>

        {/* 详细反馈 */}
        <div>
          <Label>具体建议</Label>
          <Textarea
            placeholder="请描述具体问题和改进建议..."
            value={feedbackText}
            onChange={(e) => setFeedbackText(e.target.value)}
            rows={4}
          />
        </div>

        {/* 调整目标选择 */}
        <div>
          <Label>反馈作用范围</Label>
          <RadioGroup value={adjustmentTarget} onValueChange={setAdjustmentTarget}>
            <div className="space-y-3">
              <Label className="flex items-start space-x-3 p-3 border rounded-lg cursor-pointer hover:bg-gray-50">
                <RadioGroupItem value="profile" />
                <div>
                  <div className="font-medium">类型化风格调整</div>
                  <div className="text-sm text-gray-600">只影响"{contentType}"类型的写作风格</div>
                  <div className="text-xs text-gray-500">推荐用于：特定内容类型的表达方式调整</div>
                </div>
              </Label>

              <Label className="flex items-start space-x-3 p-3 border rounded-lg cursor-pointer hover:bg-gray-50">
                <RadioGroupItem value="overview" />
                <div>
                  <div className="font-medium">全局风格调整</div>
                  <div className="text-sm text-gray-600">影响所有内容类型的整体写作风格</div>
                  <div className="text-xs text-gray-500">推荐用于：语言习惯、表达偏好等基础调整</div>
                </div>
              </Label>
            </div>
          </RadioGroup>
        </div>

        {/* 智能推荐 */}
        <div className="bg-blue-50 p-3 rounded-lg">
          <div className="text-sm text-blue-800">
            💡 智能推荐：基于您的反馈内容，建议选择
            <strong>{getRecommendedTarget(feedbackText, selectedTags)}</strong>
          </div>
        </div>

        <Button onClick={submitFeedback} className="w-full">
          提交反馈
        </Button>
      </CardContent>
    </Card>
  );
}
```

#### B. 三阶段内容展示组件
```tsx
function GenerationStagesViewer({ resultId }: { resultId: string }) {
  const [result, setResult] = useState<ArticleGenerationResult | null>(null);
  const [activeStage, setActiveStage] = useState<'outline' | 'draft' | 'final'>('final');

  const stages = [
    { key: 'outline', label: '大纲', content: result?.outlineContent },
    { key: 'draft', label: '初稿', content: result?.draftContent },
    { key: 'final', label: '最终版', content: result?.finalContent }
  ];

  return (
    <div className="space-y-4">
      {/* 阶段选择标签 */}
      <Tabs value={activeStage} onValueChange={setActiveStage}>
        <TabsList className="grid w-full grid-cols-3">
          {stages.map(stage => (
            <TabsTrigger key={stage.key} value={stage.key}>
              {stage.label}
              {stage.content && <Badge variant="outline" className="ml-2">✓</Badge>}
            </TabsTrigger>
          ))}
        </TabsList>

        {stages.map(stage => (
          <TabsContent key={stage.key} value={stage.key}>
            <Card>
              <CardHeader>
                <CardTitle>{stage.label}</CardTitle>
                {stage.key === 'final' && result?.selfReviewNotes && (
                  <div className="text-sm text-gray-600 bg-gray-50 p-3 rounded">
                    <strong>自查优化说明：</strong>
                    <p>{result.selfReviewNotes}</p>
                  </div>
                )}
              </CardHeader>
              <CardContent>
                <div className="whitespace-pre-wrap">{stage.content}</div>
              </CardContent>
            </Card>

            {/* 每个阶段都可以反馈 */}
            <FeedbackForm
              resultId={resultId}
              username={result?.task.username}
              contentType={result?.task.contentType}
              generatedContent={stage.content}
              stage={stage.key}
            />
          </TabsContent>
        ))}
      </Tabs>
    </div>
  );
}
```

### 2.2 反馈处理服务

#### A. 反馈分析与调整服务
```typescript
export class FeedbackAdjustmentService {

  async processFeedback(feedbackData: FeedbackSubmission): Promise<void> {
    // 1. 保存反馈记录
    const feedback = await this.saveFeedbackRecord(feedbackData);

    // 2. 分析反馈模式
    await this.analyzeFeedbackPattern(feedback);

    // 3. 执行相应的调整
    if (feedback.adjustmentTarget === 'overview') {
      await this.adjustUserWritingOverview(feedback);
    } else {
      await this.adjustUserStyleProfile(feedback);
    }

    // 4. 记录处理结果
    await this.markFeedbackProcessed(feedback.id);
  }

  private async adjustUserWritingOverview(feedback: FeedbackRecord): Promise<void> {
    const currentOverview = await db.userWritingOverview.findUnique({
      where: { username: feedback.username }
    });

    if (!currentOverview) {
      throw new Error(`用户 ${feedback.username} 尚未生成写作概览`);
    }

    const adjustmentPrompt = `
请基于用户反馈调整写作风格概览。

当前概览数据：
${currentOverview.overviewContent}

用户反馈信息：
- 评分：${feedback.rating}/5
- 反馈标签：${feedback.feedbackTags}
- 具体问题：${feedback.feedbackText}
- 生成阶段：${feedback.stage}

反馈针对的内容：
${feedback.targetContent}

请分析反馈并调整概览中的相关部分：

1. 如果反馈涉及"太书面化"、"语言习惯"等，调整 writingPersonality 和 toneCharacteristics
2. 如果反馈涉及"开头突兀"、"结尾无力"等，调整 typicalStructure 中的开头结尾模式
3. 如果反馈涉及"表达方式"、"句式"等，调整 typicalSentences 部分
4. 如果反馈涉及"互动感"、"语调"等，调整 toneCharacteristics

调整原则：
- 保持用户核心写作特色，只调整有问题的部分
- 基于具体反馈内容进行精准调整
- 确保调整后的概览更符合用户期望

返回完整的调整后概览JSON，保持原有数据结构：`;

    try {
      const config = await WritingAssistantConfigLoader.getAnalysisConfig();
      const aiService = AIServiceFactory.createService({
        provider: config.provider,
        model: config.model,
        apiKey: config.apiKey,
        baseURL: config.baseURL
      });

      const adjustedOverviewStr = await aiService.generateText(adjustmentPrompt);
      const adjustedOverview = JSON.parse(adjustedOverviewStr);

      // 更新数据库
      await db.userWritingOverview.update({
        where: { username: feedback.username },
        data: {
          overviewContent: JSON.stringify(adjustedOverview),
          lastUpdated: new Date(),
          version: { increment: 1 }
        }
      });

      // 记录更新日志
      await db.overviewUpdateLog.create({
        data: {
          username: feedback.username,
          updateType: 'FEEDBACK_ADJUSTMENT',
          changesMade: JSON.stringify({
            feedbackId: feedback.id,
            adjustmentSummary: `基于用户反馈调整全局写作风格`,
            specificChanges: this.extractChanges(currentOverview.overviewContent, adjustedOverviewStr)
          }),
          llmModel: config.model
        }
      });

      console.log(`用户 ${feedback.username} 的全局写作风格已根据反馈调整`);

    } catch (error) {
      console.error('调整全局写作概览失败:', error);
      throw error;
    }
  }

  private async adjustUserStyleProfile(feedback: FeedbackRecord): Promise<void> {
    const currentProfile = await db.userStyleProfile.findUnique({
      where: {
        username_contentType: {
          username: feedback.username,
          contentType: feedback.contentType
        }
      }
    });

    if (!currentProfile) {
      throw new Error(`用户 ${feedback.username} 的 ${feedback.contentType} 类型风格档案不存在`);
    }

    const adjustmentPrompt = `
请基于用户反馈调整"${feedback.contentType}"类型的具体风格档案。

当前风格档案：
- 签名词汇：${currentProfile.signatureWords || '未设置'}
- 常用开头：${currentProfile.commonOpenings || '未设置'}
- 常用结尾：${currentProfile.commonClosings || '未设置'}
- 语调特征：${currentProfile.toneFeatures || '未设置'}
- 平均句长：${currentProfile.avgSentenceLength || '未设置'}
- 句型分布：${currentProfile.sentenceTypeDist || '未设置'}
- 标点模式：${currentProfile.punctuationPattern || '未设置'}

用户反馈信息：
- 评分：${feedback.rating}/5
- 反馈标签：${feedback.feedbackTags}
- 具体问题：${feedback.feedbackText}
- 生成阶段：${feedback.stage}

反馈针对的内容示例：
${feedback.targetContent.substring(0, 500)}...

请针对具体反馈进行精准调整：

1. 如果反馈"太书面化"：
   - 调整 signatureWords，移除正式词汇，增加口语化表达
   - 调整 toneFeatures，增加随意、亲和的特征

2. 如果反馈开头/结尾问题：
   - 调整 commonOpenings/commonClosings，提供更自然的开头结尾模式

3. 如果反馈语调问题：
   - 调整 toneFeatures，根据反馈修正语调特征分布

4. 如果反馈句式问题：
   - 调整 avgSentenceLength 和 sentenceTypeDist

返回调整建议的JSON格式：
{
  "adjustments": {
    "signatureWords": "调整后的签名词汇JSON字符串或null",
    "commonOpenings": "调整后的开头模式JSON字符串或null",
    "commonClosings": "调整后的结尾模式JSON字符串或null",
    "toneFeatures": "调整后的语调特征JSON字符串或null",
    "avgSentenceLength": 调整后的平均句长数值或null,
    "sentenceTypeDist": "调整后的句型分布JSON字符串或null"
  },
  "reasoning": "详细的调整理由和说明"
}

注意：只返回需要调整的字段，不需要调整的字段设为null。`;

    try {
      const config = await WritingAssistantConfigLoader.getAnalysisConfig();
      const aiService = AIServiceFactory.createService({
        provider: config.provider,
        model: config.model,
        apiKey: config.apiKey,
        baseURL: config.baseURL
      });

      const adjustmentResultStr = await aiService.generateText(adjustmentPrompt);
      const adjustmentResult = JSON.parse(adjustmentResultStr);

      // 构建更新数据
      const updateData: any = {
        lastAnalyzedAt: new Date()
      };

      Object.entries(adjustmentResult.adjustments).forEach(([key, value]) => {
        if (value !== null) {
          updateData[key] = value;
        }
      });

      // 更新数据库
      await db.userStyleProfile.update({
        where: {
          username_contentType: {
            username: feedback.username,
            contentType: feedback.contentType
          }
        },
        data: updateData
      });

      console.log(`用户 ${feedback.username} 的 ${feedback.contentType} 类型风格档案已根据反馈调整`);
      console.log(`调整理由: ${adjustmentResult.reasoning}`);

    } catch (error) {
      console.error('调整类型化风格档案失败:', error);
      throw error;
    }
  }

  private async analyzeFeedbackPattern(feedback: FeedbackRecord): Promise<void> {
    // 解析反馈标签，更新问题模式统计
    const tags = JSON.parse(feedback.feedbackTags || '[]');

    for (const tag of tags) {
      await db.feedbackPattern.upsert({
        where: {
          username_contentType_pattern: {
            username: feedback.username,
            contentType: feedback.contentType,
            pattern: tag
          }
        },
        update: {
          frequency: { increment: 1 },
          lastOccurred: new Date(),
          feedbackType: feedback.rating <= 2 ? 'negative' : feedback.rating >= 4 ? 'positive' : 'neutral'
        },
        create: {
          username: feedback.username,
          contentType: feedback.contentType,
          pattern: tag,
          frequency: 1,
          lastOccurred: new Date(),
          feedbackType: feedback.rating <= 2 ? 'negative' : feedback.rating >= 4 ? 'positive' : 'neutral'
        }
      });
    }
  }
}
```

### 2.3 API接口设计

#### A. 反馈提交接口
```typescript
// /api/feedback/submit
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      resultId,
      stage = 'final',
      rating,
      feedbackText,
      feedbackTags = [],
      adjustmentTarget = 'profile'
    } = body;

    // 获取生成结果信息
    const result = await db.articleGenerationResult.findUnique({
      where: { id: resultId },
      include: { task: true }
    });

    if (!result) {
      return NextResponse.json({ error: 'Generation result not found' }, { status: 404 });
    }

    // 确定目标内容
    let targetContent = '';
    switch (stage) {
      case 'outline':
        targetContent = result.outlineContent || '';
        break;
      case 'draft':
        targetContent = result.draftContent || '';
        break;
      case 'final':
        targetContent = result.finalContent || result.generatedContent;
        break;
    }

    // 保存反馈并更新结果记录
    await db.articleGenerationResult.update({
      where: { id: resultId },
      data: {
        userRating: rating,
        userFeedback: feedbackText,
        feedbackTags: JSON.stringify(feedbackTags),
        adjustmentTarget,
        isImproved: false
      }
    });

    // 异步处理反馈调整
    const feedbackData = {
      resultId,
      username: result.task.username || '',
      contentType: result.task.contentType || '',
      stage,
      rating,
      feedbackText,
      feedbackTags: JSON.stringify(feedbackTags),
      adjustmentTarget,
      targetContent
    };

    // 启动异步处理
    processFeedbackAdjustment(feedbackData).catch(console.error);

    return NextResponse.json({
      success: true,
      message: '反馈已提交，系统正在处理调整...'
    });

  } catch (error) {
    console.error('提交反馈失败:', error);
    return NextResponse.json(
      { error: 'Failed to submit feedback' },
      { status: 500 }
    );
  }
}

async function processFeedbackAdjustment(feedbackData: any) {
  const adjustmentService = new FeedbackAdjustmentService();
  await adjustmentService.processFeedback(feedbackData);
}
```

#### B. 生成状态查询接口
```typescript
// /api/generation/status/:taskId
export async function GET(request: NextRequest, { params }: { params: { taskId: string } }) {
  try {
    const result = await db.articleGenerationResult.findUnique({
      where: { taskId: params.taskId },
      include: { task: true }
    });

    if (!result) {
      return NextResponse.json({ error: 'Result not found' }, { status: 404 });
    }

    const stageStatus = {
      outline: !!result.outlineContent,
      draft: !!result.draftContent,
      final: !!result.finalContent || !!result.generatedContent
    };

    return NextResponse.json({
      success: true,
      data: {
        taskId: params.taskId,
        status: result.task.status,
        stages: stageStatus,
        result: {
          outline: result.outlineContent,
          draft: result.draftContent,
          final: result.finalContent || result.generatedContent,
          selfReviewNotes: result.selfReviewNotes,
          feedback: {
            rating: result.userRating,
            text: result.userFeedback,
            tags: result.feedbackTags ? JSON.parse(result.feedbackTags) : [],
            adjustmentTarget: result.adjustmentTarget,
            isImproved: result.isImproved
          }
        }
      }
    });

  } catch (error) {
    console.error('查询生成状态失败:', error);
    return NextResponse.json(
      { error: 'Failed to fetch generation status' },
      { status: 500 }
    );
  }
}
```

## 3. 核心人格提取优化

### 3.1 多维度人格矩阵
```typescript
interface PersonalityMatrix {
  cognitive: {
    rational_emotional: number; // -1到1，-1偏感性，1偏理性
    abstract_concrete: number; // -1具体，1抽象
    critical_accepting: number; // -1包容，1批判
  };
  emotional: {
    optimistic_cautious: number; // -1谨慎，1乐观
    humorous_serious: number; // -1严肃，1幽默
    warm_authoritative: number; // -1权威，1亲和
  };
  expression: {
    concise_detailed: number; // -1简洁，1详尽
    direct_tactful: number; // -1委婉，1直接
    formal_casual: number; // -1随意，1正式
  };
  values: {
    innovative_traditional: number; // -1传统，1创新
    individual_collective: number; // -1集体，1个人
    process_result: number; // -1过程，1结果
  };
}

async function extractPersonalityMatrix(username: string): Promise<PersonalityMatrix> {
  const prompt = `基于用户的写作样本，分析其核心人格特征：

用户写作样本：
${await getUserWritingSamples(username)}

请从以下4个维度分析用户的人格特征，每个维度包含3个子维度，用-1到1的数值表示倾向：

1. 认知维度：
   - rational_emotional: 理性(-1感性，1理性)
   - abstract_concrete: 抽象(-1具体，1抽象)
   - critical_accepting: 批判(-1包容，1批判)

2. 情感维度：
   - optimistic_cautious: 乐观(-1谨慎，1乐观)
   - humorous_serious: 幽默(-1严肃，1幽默)
   - warm_authoritative: 亲和(-1权威，1亲和)

3. 表达维度：
   - concise_detailed: 详尽(-1简洁，1详尽)
   - direct_tactful: 直接(-1委婉，1直接)
   - formal_casual: 正式(-1随意，1正式)

4. 价值维度：
   - innovative_traditional: 创新(-1传统，1创新)
   - individual_collective: 个人(-1集体，1个人)
   - process_result: 结果(-1过程，1结果)

返回JSON格式的PersonalityMatrix对象。`;

  const result = await callLLM(prompt);
  return JSON.parse(result);
}
```

### 3.2 动态人格权重调整
```typescript
function getPersonalityWeights(contentType: string): Partial<PersonalityMatrix> {
  const weights: Record<string, Partial<PersonalityMatrix>> = {
    '科普': {
      cognitive: { rational_emotional: 0.8, abstract_concrete: 0.6 },
      expression: { concise_detailed: 0.7, formal_casual: 0.4 }
    },
    '搞笑': {
      emotional: { humorous_serious: 0.9, warm_authoritative: 0.7 },
      expression: { formal_casual: -0.6, direct_tactful: 0.5 }
    },
    '时事评论': {
      cognitive: { critical_accepting: 0.8, rational_emotional: 0.6 },
      expression: { direct_tactful: 0.7 }
    },
    '观点表达': {
      cognitive: { critical_accepting: 0.6 },
      values: { individual_collective: 0.5 }
    }
  };

  return weights[contentType] || {};
}

function applyPersonalityWeights(basePersonality: PersonalityMatrix, contentType: string): PersonalityMatrix {
  const weights = getPersonalityWeights(contentType);
  const adjusted = { ...basePersonality };

  // 应用权重调整
  Object.entries(weights).forEach(([dimension, dimWeights]) => {
    Object.entries(dimWeights).forEach(([trait, weight]) => {
      if (adjusted[dimension] && adjusted[dimension][trait] !== undefined) {
        // 向权重方向调整30%
        const current = adjusted[dimension][trait];
        const target = weight > 0 ? 1 : -1;
        adjusted[dimension][trait] = current + (target - current) * 0.3;
      }
    });
  });

  return adjusted;
}
```

## 4. 提示词质量深度优化

### 4.1 分层提示词架构
```typescript
interface LayeredPrompt {
  corePersonality: string;     // 核心人格层
  contentTypeStyle: string;    // 内容类型层
  contextualAdjustment: string; // 具体场景层
  feedbackCorrection: string;   // 反馈修正层
}

async function buildLayeredPrompt(task: ArticleGenerationTask, stage: 'outline' | 'draft' | 'final'): Promise<string> {
  const layers: LayeredPrompt = {
    corePersonality: await buildCorePersonalityPrompt(task.username),
    contentTypeStyle: await buildContentTypePrompt(task.username, task.contentType),
    contextualAdjustment: await buildContextualPrompt(task),
    feedbackCorrection: await buildFeedbackCorrectionPrompt(task.username, task.contentType)
  };

  let prompt = `请为以下主题撰写${stage === 'outline' ? '大纲' : stage === 'draft' ? '初稿' : '最终内容'}：

主题：${task.topic}
平台：${task.platform.name}
${task.platform.wordCount ? `字数要求：${task.platform.wordCount}` : ''}`;

  // 核心人格层
  if (layers.corePersonality) {
    prompt += `\n\n【核心写作人格】\n${layers.corePersonality}`;
  }

  // 内容类型层
  if (layers.contentTypeStyle) {
    prompt += `\n\n【${task.contentType}类型专属风格】\n${layers.contentTypeStyle}`;
  }

  // 具体场景层
  if (layers.contextualAdjustment) {
    prompt += `\n\n【场景化调整】\n${layers.contextualAdjustment}`;
  }

  // 反馈修正层
  if (layers.feedbackCorrection) {
    prompt += `\n\n【重要反馈纠正】\n${layers.feedbackCorrection}`;
  }

  // 阶段特定要求
  prompt += await buildStageSpecificRequirements(stage, task);

  return prompt;
}

async function buildFeedbackCorrectionPrompt(username: string, contentType: string): Promise<string> {
  // 获取用户最近的负面反馈模式
  const negativePatterns = await db.feedbackPattern.findMany({
    where: {
      username,
      contentType,
      feedbackType: 'negative',
      isResolved: false
    },
    orderBy: { frequency: 'desc' },
    take: 5
  });

  if (negativePatterns.length === 0) return '';

  let correctionPrompt = '请特别注意避免以下用户已反馈的问题：\n';

  negativePatterns.forEach(pattern => {
    correctionPrompt += `- ${pattern.pattern}（已出现${pattern.frequency}次）\n`;
  });

  // 添加具体的解决策略
  const strategies = getFeedbackStrategies(negativePatterns.map(p => p.pattern));
  if (strategies.length > 0) {
    correctionPrompt += '\n解决策略：\n';
    strategies.forEach(strategy => {
      correctionPrompt += `- ${strategy}\n`;
    });
  }

  return correctionPrompt;
}

function getFeedbackStrategies(patterns: string[]): string[] {
  const strategies: string[] = [];

  if (patterns.some(p => p.includes('书面化'))) {
    strategies.push('多使用"这个"、"那个"等指代词');
    strategies.push('使用"挺"、"蛮"等程度副词');
    strategies.push('采用疑问句和感叹句增加互动感');
    strategies.push('避免过于正式的书面表达');
  }

  if (patterns.some(p => p.includes('开头突兀'))) {
    strategies.push('使用自然的过渡和引入');
    strategies.push('以问题或场景开头建立连接');
  }

  if (patterns.some(p => p.includes('缺乏互动感'))) {
    strategies.push('多使用第二人称"你"');
    strategies.push('增加疑问句和反问句');
    strategies.push('使用"咱们"、"大家"等包容性词汇');
  }

  return strategies;
}
```

## 5. 分阶段实施计划

### 板块1：基础架构搭建（2-3天）
**目标**：为新功能提供数据和服务基础

#### 第1天：数据库结构升级
- **上午**：
  - 扩展 `ArticleGenerationResult` 表，添加三阶段字段
  - 新增 `FeedbackPattern` 表
  - 更新 Prisma schema 文件
- **下午**：
  - 运行数据库迁移命令
  - 验证数据库结构正确性
  - 更新相关 TypeScript 类型定义

#### 第2天：内容类型大纲模板系统
- **上午**：
  - 实现 `OUTLINE_TEMPLATES` 配置
  - 创建 `ContentTypeOutlineGenerator` 类
  - 实现 `OutlineValidator` 验证器
- **下午**：
  - 单元测试各个内容类型的大纲生成
  - 验证模板逻辑的正确性

#### 第3天：核心服务重构
- **上午**：
  - 重构 `processArticleGeneration` 函数支持三阶段
  - 实现阶段状态管理和数据保存
- **下午**：
  - 集成内容类型化大纲生成
  - 测试整个三阶段生成流程

**里程碑检查**：能够生成类型化大纲并保存到数据库

---

### 板块2：三阶段生成核心（3-4天）
**目标**：完整实现大纲→初稿→自查的三阶段生成

#### 第4天：阶段1优化（大纲生成）
- **上午**：
  - 完善 `generateOutline` 函数
  - 集成个性化风格提示词
  - 添加参考文章和内容结构支持
- **下午**：
  - 测试不同内容类型的大纲质量
  - 优化提示词和验证逻辑

#### 第5天：阶段2实现（初稿扩展）
- **上午**：
  - 实现 `generateDraft` 函数
  - 基于大纲的内容扩展逻辑
  - 集成用户风格档案
- **下午**：
  - 测试大纲到初稿的转换质量
  - 优化扩展提示词

#### 第6天：阶段3实现（自查优化）
- **上午**：
  - 实现 `selfReviewAndOptimize` 函数
  - 多维度内容质量检查
  - 自动优化和改进逻辑
- **下午**：
  - 测试自查功能的效果
  - 优化检查标准和改进策略

#### 第7天：流程集成与优化
- **上午**：
  - 完善三阶段主流程
  - 添加错误处理和重试机制
  - 性能优化和token统计
- **下午**：
  - 端到端测试完整生成流程
  - 修复发现的问题

**里程碑检查**：能够完整执行三阶段生成并产出高质量内容

---

### 板块3：用户反馈系统（2-3天）
**目标**：实现用户反馈收集和智能风格调整

#### 第8天：反馈处理服务
- **上午**：
  - 实现 `FeedbackAdjustmentService` 核心类
  - 反馈模式分析和统计
  - LLM驱动的风格调整逻辑
- **下午**：
  - 实现双层调整机制（Overview vs Profile）
  - 测试反馈处理的准确性

#### 第9天：反馈API接口
- **上午**：
  - 创建反馈提交 API (`/api/feedback/submit`)
  - 生成状态查询 API (`/api/generation/status/:taskId`)
  - 异步反馈处理队列
- **下午**：
  - API测试和错误处理
  - 与现有文章生成流程集成

#### 第10天：智能推荐系统
- **上午**：
  - 实现反馈策略映射 (`getFeedbackStrategies`)
  - 智能推荐调整目标逻辑
  - 负面模式识别和预防
- **下午**：
  - 测试推荐系统的准确性
  - 优化推荐算法

**里程碑检查**：用户反馈能够正确调整写作风格

---

### 板块4：前端交互界面（2-3天）
**目标**：提供用户友好的三阶段内容展示和反馈界面

#### 第11天：三阶段展示组件
- **上午**：
  - 实现 `GenerationStagesViewer` 组件
  - 阶段切换和内容展示
  - 生成进度指示器
- **下午**：
  - 自查优化说明展示
  - 响应式设计和样式优化

#### 第12天：反馈收集组件
- **上午**：
  - 实现 `FeedbackForm` 组件
  - 评分、标签和文本反馈
  - 调整目标选择界面
- **下午**：
  - 智能推荐提示
  - 表单验证和提交逻辑

#### 第13天：界面集成与优化
- **上午**：
  - 集成到现有的文章生成页面
  - 添加加载状态和错误处理
  - 用户体验优化
- **下午**：
  - 移动端适配
  - 交互细节完善

**里程碑检查**：用户可以直观地查看三阶段内容并提交反馈

---

### 板块5：测试与部署优化（1-2天）
**目标**：确保系统稳定性和性能

#### 第14天：综合测试
- **上午**：
  - 端到端功能测试
  - 不同内容类型的生成测试
  - 反馈调整效果验证
- **下午**：
  - 性能测试和优化
  - 内存使用和LLM调用优化
  - 并发处理测试

#### 第15天：部署准备（可选）
- **上午**：
  - 生产环境配置检查
  - 数据库迁移脚本准备
  - 监控和日志配置
- **下午**：
  - 文档更新和使用说明
  - 备份和回滚方案

**里程碑检查**：系统在生产环境稳定运行

---

## 实施策略建议

### **渐进式推进**
1. **先核心后扩展**：优先实现三阶段生成，再添加反馈功能
2. **先后端后前端**：确保数据和逻辑正确后再开发界面
3. **小步快跑**：每个板块都有独立的里程碑检查

### **风险控制**
1. **向下兼容**：确保新功能不影响现有的单阶段生成
2. **功能开关**：使用配置开关控制新功能的启用
3. **数据备份**：重要数据库变更前做好备份

### **测试策略**
1. **单元测试**：每个核心函数都有对应测试
2. **集成测试**：验证各个板块的协作
3. **用户测试**：真实场景下的体验验证

### **性能考虑**
1. **缓存策略**：大纲模板和用户风格数据缓存
2. **异步处理**：长时间的LLM调用使用后台队列
3. **资源限制**：设置合理的并发限制和超时时间

**总计：15天完成全部功能，最短可压缩至12天**

## 6. 关键技术要点

### A. 并发处理
- 三阶段生成使用串行处理，确保逻辑依赖
- 反馈处理使用异步队列，避免阻塞用户界面
- 使用deduplicationManager防止重复处理

### B. 错误恢复
- 每个阶段独立保存，支持断点续传
- 失败阶段可以重新执行，不影响已完成阶段
- 提供详细的错误日志和状态追踪

### C. 性能优化
- LLM调用使用缓存机制
- 反馈模式分析使用批量处理
- 数据库查询优化和索引设计

### D. 扩展性设计
- 支持新增生成阶段
- 支持新的反馈类型和调整目标
- 模块化的服务设计，便于维护和扩展


——————研发计划——————

实施计划概览

  🏗️ 板块1：基础架构搭建（2-3天）

  - 数据库结构升级：三阶段字段、反馈表
  - 内容类型大纲模板系统：12种类型的完整模板
  - 核心服务重构：支持三阶段的生成流程

  ⚙️ 板块2：三阶段生成核心（3-4天）

  - 阶段1优化：类型化大纲生成
  - 阶段2实现：基于大纲的初稿扩展
  - 阶段3实现：自查优化和质量提升
  - 流程集成：完整的端到端生成

  🔄 板块3：用户反馈系统（2-3天）

  - 反馈处理服务：LLM驱动的风格调整
  - 反馈API接口：提交和状态查询
  - 智能推荐系统：自动推荐调整目标

  🎨 板块4：前端交互界面（2-3天）

  - 三阶段展示组件：大纲/初稿/最终版切换
  - 反馈收集组件：评分、标签、调整目标选择
  - 界面集成优化：用户体验和响应式设计

  🧪 板块5：测试与部署优化（1-2天）

  - 综合测试：功能、性能、并发测试
  - 部署准备：生产环境配置和监控

  关键特点

  📈 渐进式推进

  - 每个板块都有独立的里程碑检查
  - 先核心后扩展：优先保证基础功能稳定
  - 先后端后前端：确保数据逻辑正确

  🛡️ 风险控制

  - 向下兼容：不影响现有单阶段生成
  - 功能开关：配置控制新功能启用
  - 数据备份：重要变更前的安全保障

  ⚡ 性能考虑

  - 缓存策略：模板和用户数据缓存
  - 异步处理：LLM调用后台队列
  - 资源限制：合理的并发和超时控制