# 基于风格分析的个性化推文生成方案

## 📋 方案概述

完全重构现有"内容生成"功能,改为**个性化推文生成器**,让用户仅通过输入`username`和`内容类型`即可生成符合其写作风格的推文。系统将充分利用已有的写作分析数据,包括:

1. **UserWritingOverview** (LLM驱动的写作概览)
2. **UserStyleProfile** (类型化的风格档案)
3. **TweetTypeAnnotation** (推文类型标注数据)
4. **WritingAnalysisTweet** (用户历史推文)

---

## 🎯 核心设计理念

### 从"文章生成"到"推文生成"
- **旧模式**: 主题 + 平台 + 参考文章 + 内容结构 → 生成长文章
- **新模式**: username + 内容类型 → 生成风格化推文

### 数据驱动的个性化
完全依赖分析系统已收集的用户风格数据,不需要额外配置:
```
用户数据 → 风格分析 → 内容生成 → 个性化推文
```

---

## 📊 系统架构设计

### 1. 数据层改造

#### 1.1 新增推文生成任务表
```prisma
// 推文生成任务表
model TweetGenerationTask {
  id                String   @id @default(cuid())

  // 基本输入参数
  username          String   // 目标用户名 @testuser
  contentType       String   // 内容类型,对应TWEET_TYPES
  topic             String?  // 可选的主题/话题

  // 生成配置
  generateCount     Int      @default(3) // 生成推文数量
  lengthPreference  String   @default("auto") // auto | short | medium | long

  // AI配置
  aiProvider        String   @default("openai")
  aiModel           String   @default("gpt-4o")
  temperature       Float    @default(0.7) // 较高温度保持创意

  // 任务状态
  status            String   @default("pending") // pending | processing | completed | failed
  errorMessage      String?

  // 时间字段
  startedAt         DateTime?
  completedAt       DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // 关联的生成结果
  results           TweetGenerationResult[]

  @@index([username])
  @@index([contentType])
  @@index([status])
  @@index([createdAt])
  @@map("tweet_generation_task")
}

// 推文生成结果表
model TweetGenerationResult {
  id                String   @id @default(cuid())
  taskId            String   // 关联任务

  // 生成内容
  generatedContent  String   // 生成的推文内容
  contentLength     Int      // 字符数

  // 风格一致性评分
  styleScore        Float?   // AI自评的风格匹配度 0-1
  styleAnalysis     String?  // JSON: 风格分析说明

  // 使用的风格数据快照
  styleDataSnapshot String?  // JSON: 记录使用了哪些风格特征

  // 用户反馈
  userRating        Int?     // 1-5星评分
  userFeedback      String?  // 用户反馈文本
  isSelected        Boolean  @default(false) // 是否被用户选中使用

  // 元数据
  aiProvider        String
  aiModel           String
  generatedAt       DateTime @default(now())
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  task              TweetGenerationTask @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@index([taskId])
  @@index([userRating])
  @@index([isSelected])
  @@index([generatedAt])
  @@map("tweet_generation_result")
}
```

#### 1.2 数据关系图
```
User (@username)
    │
    ├─→ WritingAnalysisTweet (历史推文)
    │       └─→ TweetTypeAnnotation (类型标注)
    │
    ├─→ UserWritingOverview (LLM写作概览)
    │       └─ 整体风格/句式/钩子策略
    │
    └─→ UserStyleProfile (类型化风格档案)
            └─ contentType特定的风格特征

以上数据 → TweetGenerationTask → TweetGenerationResult
```

---

## 🏗️ 生成流程设计

### Phase 1: 风格数据加载 (Style Data Loading)

```typescript
interface StyleContext {
  username: string;
  contentType: string;
  writingOverview: {
    personality: string;
    toneCharacteristics: string[];
    typicalOpenings: any;
    typicalDevelopment: any;
    typicalClosings: any;
    highFrequencySentences: any[];
    emotionalExpressions: any[];
    primaryHooks: any[];
    engagementTactics: any[];
    openingHooks: any[];
    sustainingTechniques: any[];
    closingTechniques: any[];
  };
  typeSpecificStyle: {
    signatureWords: any[];
    vocabDiversity: number | null;
    wordComplexity: number | null;
    avgSentenceLength: number | null;
    sentenceTypeDist: any;
    punctuationPattern: any;
    technicalTermUsage: number | null;
    industryKnowledgeLevel: string | null;
    commonOpenings: string[];
    commonClosings: string[];
    avgContentLength: number | null;
    toneFeatures: any;
    sampleCount: number | null;
  };
  exampleTweets: string[];
  typeDefinition: {
    category: string;
    keywords: string[];
    patterns: string[];
    tone: string;
  };
}

async function loadUserStyleData(username: string, contentType: string): Promise<StyleContext> {

  // 1. 加载LLM驱动的写作概览
  const writingOverview = await db.userWritingOverview.findUnique({
    where: { username }
  });

  if (!writingOverview) {
    throw new Error(`用户 ${username} 尚未生成写作概览,请先运行风格分析`);
  }

  const overview = JSON.parse(writingOverview.overviewContent) as UserWritingOverview;


  // 2. 加载该内容类型的风格档案
  const styleProfile = await db.userStyleProfile.findUnique({
    where: {
      username_contentType: { username, contentType }
    }
  });

  if (!styleProfile) {
    throw new Error(`用户 ${username} 尚未生成 "${contentType}" 类型的风格档案`);
  }


  // 3. 获取该类型的推文样本 (最多10条,作为Few-shot示例)
  const typedTweets = await db.writingAnalysisTweet.findMany({
    where: {
      userUsername: username,
      typeAnnotations: {
        some: {
          tweetTypes: { contains: contentType } // JSON字段包含该类型
        }
      }
    },
    select: { content: true },
    orderBy: { publishedAt: 'desc' },
    take: 10
  });


  // 4. 获取该类型的配置信息
  const typeConfig = TWEET_TYPES[contentType as TweetType];


  // 5. 构建风格上下文
  return {
    username,
    contentType,

    // 全局风格特征
    writingOverview: {
      personality: overview.overallStyle.writingPersonality,
      toneCharacteristics: overview.overallStyle.toneCharacteristics,

      // 典型结构
      typicalOpenings: overview.typicalStructure.openingPatterns,
      typicalDevelopment: overview.typicalStructure.developmentPatterns,
      typicalClosings: overview.typicalStructure.closingPatterns,

      // 典型句式
      highFrequencySentences: overview.typicalSentences.highFrequencyPatterns,
      emotionalExpressions: overview.typicalSentences.emotionalExpressions,

      // 吸引力机制
      primaryHooks: overview.attractionMechanisms.primaryHooks,
      engagementTactics: overview.attractionMechanisms.engagementTactics,

      // 情绪钩子
      openingHooks: overview.emotionalHookStrategies.openingHooks,
      sustainingTechniques: overview.emotionalHookStrategies.sustainingTechniques,
      closingTechniques: overview.emotionalHookStrategies.closingTechniques
    },

    // 类型特定风格
    typeSpecificStyle: {
      // 词汇特征
      signatureWords: styleProfile.signatureWords ? JSON.parse(styleProfile.signatureWords) : [],
      vocabDiversity: styleProfile.vocabDiversity,
      wordComplexity: styleProfile.wordComplexity,

      // 句式特征
      avgSentenceLength: styleProfile.avgSentenceLength,
      sentenceTypeDist: styleProfile.sentenceTypeDist ? JSON.parse(styleProfile.sentenceTypeDist) : null,
      punctuationPattern: styleProfile.punctuationPattern ? JSON.parse(styleProfile.punctuationPattern) : null,

      // 专业度
      technicalTermUsage: styleProfile.technicalTermUsage,
      industryKnowledgeLevel: styleProfile.industryKnowledgeLevel,

      // 该类型特有的开头/结尾
      commonOpenings: styleProfile.commonOpenings ? JSON.parse(styleProfile.commonOpenings) : [],
      commonClosings: styleProfile.commonClosings ? JSON.parse(styleProfile.commonClosings) : [],
      avgContentLength: styleProfile.avgContentLength,
      toneFeatures: styleProfile.toneFeatures ? JSON.parse(styleProfile.toneFeatures) : {},

      sampleCount: styleProfile.sampleCount
    },

    // Few-shot示例
    exampleTweets: typedTweets.map(t => t.content),

    // 类型定义
    typeDefinition: {
      category: typeConfig.category,
      keywords: typeConfig.keywords,
      patterns: typeConfig.patterns,
      tone: typeConfig.tone
    }
  };
}
```

### Phase 2: Prompt构建 (Prompt Engineering)

```typescript
function buildGenerationPrompt(styleContext: StyleContext, topic?: string, count: number = 3): string {

  const { username, contentType, writingOverview, typeSpecificStyle, exampleTweets, typeDefinition } = styleContext;

  return `你是一个专业的社交媒体内容创作助手。你的任务是模仿用户"${username}"的写作风格,生成${count}条"${contentType}"类型的推文。

# 用户写作风格档案

## 整体写作人格
- **写作人格**: ${writingOverview.personality}
- **语调特征**: ${writingOverview.toneCharacteristics.join('、')}

## 典型行文结构

### 开头模式
- **主要模式**: ${writingOverview.typicalOpenings.primaryPattern}
- **描述**: ${writingOverview.typicalOpenings.description}
- **典型例子**:
${writingOverview.typicalOpenings.examples.map((ex: string, i: number) => `  ${i+1}. "${ex}"`).join('\n')}

### 展开模式
- **主要模式**: ${writingOverview.typicalDevelopment.primaryPattern}
- **描述**: ${writingOverview.typicalDevelopment.description}
- **特征**: ${writingOverview.typicalDevelopment.characteristics.join('、')}

### 结尾模式
- **主要模式**: ${writingOverview.typicalClosings.primaryPattern}
- **描述**: ${writingOverview.typicalClosings.description}

## 典型句式模板

### 高频句式
${writingOverview.highFrequencySentences.slice(0, 3).map((pattern: any, i: number) => `
${i+1}. **${pattern.pattern}**
   - 用法: ${pattern.description}
   - 场景: ${pattern.context}
   - 例子: ${pattern.examples.slice(0, 2).join(' / ')}
`).join('')}

### 情感表达方式
${writingOverview.emotionalExpressions.slice(0, 2).map((exp: any, i: number) => `
${i+1}. **${exp.emotion}**
   - 表达: ${exp.expressions.join('、')}
`).join('')}

## 吸引力机制

### 主要钩子策略
${writingOverview.primaryHooks.slice(0, 2).map((hook: any, i: number) => `
${i+1}. **${hook.type}**
   - 工作机制: ${hook.description}
   - 效果: ${hook.effectiveness}
   - 例子: "${hook.examples[0]}"
`).join('')}

### 互动策略
${writingOverview.engagementTactics.slice(0, 2).map((tactic: any, i: number) => `
${i+1}. **${tactic.tactic}**
   - ${tactic.description}
   - 使用时机: ${tactic.whenToUse}
`).join('')}

## "${contentType}"类型专属风格

### 内容类型定义
- **类别**: ${typeDefinition.category}
- **典型特征**: ${typeDefinition.patterns.join('、')}
- **语气**: ${typeDefinition.tone}

### 该类型的词汇特征
- **词汇丰富度**: ${((typeSpecificStyle.vocabDiversity || 0) * 100).toFixed(0)}%
- **平均词长**: ${(typeSpecificStyle.wordComplexity || 2).toFixed(1)}字符
- **标志性词汇**: ${typeSpecificStyle.signatureWords.slice(0, 10).map((w: any) => w.word).join('、')}

### 该类型的句式特征
- **平均句长**: ${(typeSpecificStyle.avgSentenceLength || 20).toFixed(0)}字
${typeSpecificStyle.sentenceTypeDist ? `
- **句型分布**:
  - 陈述句: ${(typeSpecificStyle.sentenceTypeDist.declarative * 100).toFixed(0)}%
  - 疑问句: ${(typeSpecificStyle.sentenceTypeDist.interrogative * 100).toFixed(0)}%
  - 感叹句: ${(typeSpecificStyle.sentenceTypeDist.exclamatory * 100).toFixed(0)}%
` : ''}

### 该类型常用开头 (从以下模式中选择或组合)
${typeSpecificStyle.commonOpenings.slice(0, 5).map((opening: string, i: number) => `${i+1}. "${opening}"`).join('\n')}

### 该类型常用结尾 (从以下模式中选择或组合)
${typeSpecificStyle.commonClosings.slice(0, 5).map((closing: string, i: number) => `${i+1}. "${closing}"`).join('\n')}

### 该类型的语气特征
${Object.entries(typeSpecificStyle.toneFeatures || {})
  .filter(([_, value]) => (value as number) > 0.2)
  .map(([tone, value]) => `- ${tone}: ${((value as number) * 100).toFixed(0)}%`)
  .join('\n')}

### 该类型的专业度
- **技术术语使用率**: ${((typeSpecificStyle.technicalTermUsage || 0) * 100).toFixed(0)}%
- **行业知识水平**: ${typeSpecificStyle.industryKnowledgeLevel || 'intermediate'}

### 该类型的典型长度
- **平均字符数**: ${(typeSpecificStyle.avgContentLength || 140).toFixed(0)}字符

## 实际写作样本 (Few-shot Examples)

以下是用户"${username}"实际发布的"${contentType}"类型推文,供你参考模仿:

${exampleTweets.slice(0, 5).map((tweet: string, i: number) => `
【样本${i+1}】
${tweet}
`).join('\n---\n')}

---

# 生成任务

${topic ? `
## 指定话题
${topic}

请围绕这个话题,以用户的风格生成推文。
` : `
## 自由创作
请基于用户的常见话题和风格,生成符合"${contentType}"类型特征的推文。
`}

## 生成要求

1. **严格模仿风格**:
   - 必须使用用户的典型开头模式之一
   - 必须使用用户的高频句式模板
   - 必须体现用户的语调特征
   - 内容长度接近用户该类型的平均长度

2. **符合类型定义**:
   - 内容必须符合"${contentType}"的类型特征
   - 使用该类型的典型结构模式
   - 体现该类型的语气特征

3. **保持吸引力**:
   - 使用用户有效的钩子策略
   - 如果适用,包含互动元素
   - 确保内容有价值或有趣

4. **自然真实**:
   - 不要刻意堆砌特征
   - 保持内容的自然流畅
   - 像用户本人在写作

## 输出格式

请生成${count}条推文,用JSON格式返回:

\`\`\`json
{
  "tweets": [
    {
      "content": "推文内容",
      "styleAnalysis": {
        "openingPattern": "使用的开头模式",
        "sentencePatterns": ["使用的句式模板1", "使用的句式模板2"],
        "hooks": ["使用的钩子策略1"],
        "styleScore": 0.95,
        "explanation": "为什么这条推文符合用户风格的简要说明"
      }
    }
  ]
}
\`\`\`

现在请开始生成:`;
}
```

### Phase 3: 生成执行 (Generation Execution)

```typescript
async function generateTweets(
  username: string,
  contentType: string,
  options: {
    topic?: string;
    count?: number;
    aiProvider?: string;
    aiModel?: string;
    temperature?: number;
  } = {}
): Promise<TweetGenerationResult[]> {

  const {
    topic,
    count = 3,
    aiProvider = 'openai',
    aiModel = 'gpt-4o',
    temperature = 0.7
  } = options;


  // 1. 创建任务记录
  const task = await db.tweetGenerationTask.create({
    data: {
      username,
      contentType,
      topic: topic || null,
      generateCount: count,
      aiProvider,
      aiModel,
      temperature,
      status: 'processing',
      startedAt: new Date()
    }
  });


  try {
    // 2. 加载风格数据
    console.log(`[${task.id}] 加载用户 ${username} 的 "${contentType}" 风格数据...`);
    const styleContext = await loadUserStyleData(username, contentType);


    // 3. 构建生成prompt
    console.log(`[${task.id}] 构建生成prompt...`);
    const prompt = buildGenerationPrompt(styleContext, topic, count);


    // 4. 调用AI生成
    console.log(`[${task.id}] 调用 ${aiProvider}/${aiModel} 生成推文...`);
    const config = await WritingAssistantConfigLoader.getAnalysisConfig();
    const aiService = AIServiceFactory.createService({
      provider: aiProvider,
      model: aiModel,
      apiKey: config.apiKey,
      baseURL: config.baseURL
    });

    const rawResult = await aiService.generateText(prompt, { temperature });


    // 5. 解析结果
    console.log(`[${task.id}] 解析生成结果...`);
    const cleanResult = rawResult.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    const parsed = JSON.parse(cleanResult);

    if (!parsed.tweets || !Array.isArray(parsed.tweets)) {
      throw new Error('生成结果格式错误');
    }


    // 6. 保存结果
    console.log(`[${task.id}] 保存生成结果...`);
    const results = await Promise.all(
      parsed.tweets.map(async (tweet: any) => {
        return await db.tweetGenerationResult.create({
          data: {
            taskId: task.id,
            generatedContent: tweet.content,
            contentLength: tweet.content.length,
            styleScore: tweet.styleAnalysis?.styleScore || null,
            styleAnalysis: JSON.stringify(tweet.styleAnalysis || {}),
            styleDataSnapshot: JSON.stringify({
              username,
              contentType,
              profileSampleCount: styleContext.typeSpecificStyle.sampleCount,
              usedOpeningPattern: tweet.styleAnalysis?.openingPattern,
              usedSentencePatterns: tweet.styleAnalysis?.sentencePatterns,
              usedHooks: tweet.styleAnalysis?.hooks
            }),
            aiProvider,
            aiModel
          }
        });
      })
    );


    // 7. 更新任务状态
    await db.tweetGenerationTask.update({
      where: { id: task.id },
      data: {
        status: 'completed',
        completedAt: new Date()
      }
    });

    console.log(`[${task.id}] ✅ 成功生成 ${results.length} 条推文`);
    return results;

  } catch (error) {
    console.error(`[${task.id}] ❌ 生成失败:`, error);

    await db.tweetGenerationTask.update({
      where: { id: task.id },
      data: {
        status: 'failed',
        errorMessage: error instanceof Error ? error.message : '未知错误',
        completedAt: new Date()
      }
    });

    throw error;
  }
}
```

---

## 🎨 前端界面设计

### 页面结构: `/writing-assistant/tweet-generation`

#### 页面主要元素:

1. **用户选择区域**
   - 下拉框选择username (从WritingAnalysisTweet表获取所有唯一username)
   - 显示该用户的基本统计: 总推文数、已分析类型数、最后分析时间

2. **内容类型选择区域**
   - 单选框或下拉框选择contentType
   - 显示该类型的定义、特征、样本数量
   - 预览该用户在这个类型下的3-5条历史推文样本

3. **可选参数区域**
   - 话题输入框 (可选)
   - 生成数量 (1-5条, 默认3条)
   - 长度偏好 (auto/short/medium/long)

4. **风格预览区域**
   - 显示该用户在该类型下的风格特征摘要:
     * 常用开头: 前3个
     * 平均句长
     * 高频词汇
     * 语气特征

5. **生成历史区域**
   - 显示最近的生成任务
   - 每个任务显示: username、类型、生成时间、生成数量
   - 点击查看详情可以看到生成的推文和风格分析

6. **生成结果展示区域**
   - 以卡片形式展示每条生成的推文
   - 每个卡片显示:
     * 推文内容
     * 风格匹配度评分
     * 使用的开头模式
     * 使用的句式模板
     * 操作按钮: 复制、评分、反馈

### 界面示意图

```
┌─────────────────────────────────────────────────────────────┐
│  推文生成 (Tweet Generation)                                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  [1] 选择用户                                                │
│      ┌────────────────────────────────────┐                 │
│      │ @testuser ▼                        │                 │
│      └────────────────────────────────────┘                 │
│      📊 共1250条推文 | 已分析12种类型 | 最后分析: 2天前     │
│                                                              │
├─────────────────────────────────────────────────────────────┤
│  [2] 选择内容类型                                            │
│      ┌──────────┐ ┌──────────┐ ┌──────────┐                │
│      │ 科普     │ │ 教程/技巧│ │ 洞见/观点│  ...           │
│      │ (245条)  │ │ (183条)  │ │ (327条)  │                │
│      └──────────┘ └──────────┘ └──────────┘                │
│                                                              │
│      💡 类型定义: 内容导向类 - 解释概念、阐述原理            │
│      📝 典型模式: 问题+解释、概念+阐述                       │
│                                                              │
├─────────────────────────────────────────────────────────────┤
│  [3] 风格预览                                                │
│      ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓    │
│      ┃ 常用开头: "你知道吗"、"很多人不知道"、"科普一下"     │
│      ┃ 平均句长: 23字                                   ┃    │
│      ┃ 高频词汇: 数据、研究、分析、发现、显示                ┃    │
│      ┃ 语气特征: 客观(72%)、严谨(58%)、专业(65%)           ┃    │
│      ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛    │
│                                                              │
├─────────────────────────────────────────────────────────────┤
│  [4] 生成参数 (可选)                                         │
│      话题: [____________________] (选填)                     │
│      生成数量: [3 ▼]    长度: [自动 ▼]                      │
│                                                              │
│      [🚀 开始生成]                                           │
│                                                              │
├─────────────────────────────────────────────────────────────┤
│  [5] 生成结果                                                │
│                                                              │
│  ┌─────────────────────────────────────────────┐            │
│  │ 推文 #1                        风格匹配: 94% │            │
│  ├─────────────────────────────────────────────┤            │
│  │ 你知道吗,AI模型的训练其实是一个...             │            │
│  │                                               │            │
│  ├─────────────────────────────────────────────┤            │
│  │ ✓ 开头: "你知道吗" (常用模式1)                │            │
│  │ ✓ 句式: 疑问引入+专业解释                     │            │
│  │ ✓ 钩子: 知识缺口                             │            │
│  ├─────────────────────────────────────────────┤            │
│  │ [📋 复制] [⭐ 评分] [💬 反馈]                │            │
│  └─────────────────────────────────────────────┘            │
│                                                              │
│  ┌─────────────────────────────────────────────┐            │
│  │ 推文 #2                        风格匹配: 91% │            │
│  │ ...                                          │            │
│  └─────────────────────────────────────────────┘            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 🔌 API路由设计

### tRPC Router: `tweetGenerationRouter`

```typescript
export const tweetGenerationRouter = createTRPCRouter({

  // 获取可用的用户列表
  getAvailableUsers: publicProcedure
    .query(async () => {
      const users = await db.writingAnalysisTweet.groupBy({
        by: ['userUsername'],
        _count: { id: true },
        orderBy: { _count: { id: 'desc' } }
      });

      return users.map(u => ({
        username: u.userUsername,
        tweetCount: u._count.id
      }));
    }),


  // 获取用户在各类型下的样本数量
  getUserTypeStats: publicProcedure
    .input(z.object({ username: z.string() }))
    .query(async ({ input }) => {
      const profiles = await db.userStyleProfile.findMany({
        where: { username: input.username },
        select: {
          contentType: true,
          sampleCount: true,
          lastAnalyzedAt: true
        }
      });

      return {
        username: input.username,
        types: profiles.map(p => ({
          contentType: p.contentType,
          sampleCount: p.sampleCount,
          lastAnalyzed: p.lastAnalyzedAt
        }))
      };
    }),


  // 预览用户在特定类型下的风格特征
  previewUserStyle: publicProcedure
    .input(z.object({
      username: z.string(),
      contentType: z.string()
    }))
    .query(async ({ input }) => {
      const styleContext = await loadUserStyleData(
        input.username,
        input.contentType
      );

      return {
        username: input.username,
        contentType: input.contentType,
        preview: {
          commonOpenings: styleContext.typeSpecificStyle.commonOpenings.slice(0, 3),
          avgSentenceLength: styleContext.typeSpecificStyle.avgSentenceLength,
          signatureWords: styleContext.typeSpecificStyle.signatureWords.slice(0, 10),
          toneFeatures: styleContext.typeSpecificStyle.toneFeatures,
          sampleCount: styleContext.typeSpecificStyle.sampleCount,
          exampleTweets: styleContext.exampleTweets.slice(0, 3)
        }
      };
    }),


  // 创建生成任务
  createGenerationTask: publicProcedure
    .input(z.object({
      username: z.string().min(1),
      contentType: z.string().min(1),
      topic: z.string().optional(),
      generateCount: z.number().int().min(1).max(5).default(3),
      lengthPreference: z.enum(['auto', 'short', 'medium', 'long']).default('auto'),
      aiProvider: z.string().default('openai'),
      aiModel: z.string().default('gpt-4o'),
      temperature: z.number().min(0).max(1).default(0.7)
    }))
    .mutation(async ({ input }) => {
      // 异步执行生成
      generateTweets(input.username, input.contentType, {
        topic: input.topic,
        count: input.generateCount,
        aiProvider: input.aiProvider,
        aiModel: input.aiModel,
        temperature: input.temperature
      }).catch(console.error);

      return { success: true, message: '生成任务已创建' };
    }),


  // 获取生成历史
  getGenerationHistory: publicProcedure
    .input(z.object({
      username: z.string().optional(),
      limit: z.number().int().min(1).max(50).default(20),
      offset: z.number().int().min(0).default(0)
    }))
    .query(async ({ input }) => {
      const tasks = await db.tweetGenerationTask.findMany({
        where: input.username ? { username: input.username } : undefined,
        include: {
          results: {
            select: {
              id: true,
              generatedContent: true,
              styleScore: true,
              userRating: true
            }
          }
        },
        orderBy: { createdAt: 'desc' },
        take: input.limit,
        skip: input.offset
      });

      return { tasks };
    }),


  // 提交用户反馈
  submitFeedback: publicProcedure
    .input(z.object({
      resultId: z.string(),
      rating: z.number().int().min(1).max(5),
      feedback: z.string().optional()
    }))
    .mutation(async ({ input }) => {
      await db.tweetGenerationResult.update({
        where: { id: input.resultId },
        data: {
          userRating: input.rating,
          userFeedback: input.feedback
        }
      });

      return { success: true };
    })
});
```

---

## ✅ 实施步骤

### 第一步: 数据库迁移
1. 在`prisma/schema.prisma`中添加`TweetGenerationTask`和`TweetGenerationResult`表定义
2. 运行Prisma迁移: `npx prisma migrate dev --name add_tweet_generation`
3. 验证数据库表结构正确创建

### 第二步: 后端服务实现
1. 创建`src/server/services/tweet-generation.ts`
   - 实现`loadUserStyleData()`函数
   - 实现`buildGenerationPrompt()`函数
   - 实现`generateTweets()`函数
2. 创建`src/server/api/routers/tweet-generation.ts`
   - 实现所有tRPC路由endpoint
3. 在`src/server/api/root.ts`中注册新路由

### 第三步: 前端页面开发
1. 创建`src/app/writing-assistant/tweet-generation/page.tsx`
2. 实现用户选择组件
3. 实现内容类型选择组件
4. 实现风格预览组件
5. 实现生成结果展示组件
6. 集成tRPC API调用
7. 添加加载状态和错误处理

### 第四步: 导航和集成
1. 在`src/components/navigation.tsx`中添加新页面入口
2. 更新API文档页面,添加新的endpoint说明
3. 添加用户引导和帮助文档

### 第五步: 测试和优化
1. 使用现有用户数据进行生成测试
2. 评估生成质量和风格一致性
3. 收集用户反馈并记录
4. 根据反馈调整prompt策略
5. 优化生成速度和成功率
6. 完善UI/UX体验

---

## 🎯 方案优势

### 1. **零配置个性化**
用户只需输入username和类型,系统自动应用所有已分析的风格数据,无需手动配置任何参数。

### 2. **多层次风格融合**
- **UserWritingOverview**提供整体风格框架(人格、语调、结构)
- **UserStyleProfile**提供类型特定细节(词汇、句式、专业度)
- **历史推文样本**提供Few-shot示例
- 三者结合确保高度风格一致性

### 3. **可解释性强**
每条生成的推文都附带详细的风格分析:
- 使用的开头模式
- 使用的句式模板
- 使用的钩子策略
- 风格匹配度评分(0-1)
- 生成理由说明

### 4. **持续改进机制**
- 用户反馈数据持续积累
- 可以基于反馈数据分析常见问题
- 支持prompt策略的迭代优化
- 风格分析数据定期更新同步

### 5. **与现有系统无缝集成**
- 完全利用已有的分析数据和表结构
- 不需要额外的训练或模型微调
- 遵循现有的AI配置管理体系
- 复用现有的服务和工具函数

### 6. **类型系统完整**
- 支持TWEET_TYPES中定义的所有类型
- 每个类型都有明确的特征定义
- 类型化的风格档案确保生成准确性

### 7. **灵活的扩展性**
- 可以轻松添加新的生成参数
- 支持自定义话题和长度偏好
- 可以调整AI模型和温度参数
- 便于未来添加更多风格维度

---

## 📊 预期效果

### 典型使用场景

```
用户操作:
1. 选择用户: @testuser
2. 选择类型: "科普"
3. (可选) 输入话题: "神经网络"
4. 点击生成

系统处理:
1. 加载@testuser的写作概览
2. 加载"科普"类型的245条样本分析
3. 提取常用开头、句式、钩子策略
4. 生成3条推文

生成结果:
推文1: "你知道吗,神经网络的训练过程其实就像..." (风格匹配94%)
推文2: "科普一下,为什么神经网络需要激活函数..." (风格匹配91%)
推文3: "很多人不知道,其实深度学习和传统机器学习..." (风格匹配93%)
```

### 质量保证

1. **风格一致性**: 通过多层次风格数据融合,确保生成内容与用户历史推文高度一致
2. **类型准确性**: 基于类型定义和样本分析,确保内容符合选定类型的特征
3. **内容质量**: 利用用户有效的吸引力机制和钩子策略,确保内容有吸引力
4. **可控性**: 支持话题指定和参数调整,满足不同场景需求

---

## 🚀 总结

这个方案实现了真正的**"分析驱动生成"**,通过充分利用已有的写作分析数据,让每个用户都能拥有自己专属的AI写作助手。

核心价值:
- ✅ **个性化**: 每个用户生成的内容都符合其独特风格
- ✅ **精准性**: 基于大量样本分析,确保风格特征准确
- ✅ **易用性**: 只需两个参数(username + 类型)即可生成
- ✅ **可扩展**: 随着分析数据增加,生成质量持续提升
- ✅ **可控性**: 支持话题、数量、长度等参数自定义

系统已经完成了数据收集和分析的基础建设,现在是时候让这些数据真正发挥价值,为用户提供实用的内容生成服务! 🎉