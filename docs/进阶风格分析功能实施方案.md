# 进阶风格分析功能实施方案

## 📋 概述

本文档详细说明如何实现和应用5个进阶风格分析功能，包括数据库设计、分析算法、API接口、前端展示，以及在内容生成中的具体应用方式。

---

## 🎯 功能1：开头模式识别

### 1.1 分析目标

识别用户习惯的**开头套路**，包括：
- 疑问开头（"你知道吗？"）
- 数据开头（"数据显示..."）
- 故事开头（"昨天遇到..."）
- 对比开头（"很多人以为...但实际上..."）
- 紧急开头（"刚刚！突发！"）
- 陈述开头（直接陈述事实）

### 1.2 数据库设计

#### 扩展 user_style_profile 表
```sql
ALTER TABLE user_style_profile ADD COLUMN
  -- 开头模式分布（JSON）
  opening_patterns TEXT;

-- 示例数据格式
{
  "questionHook": 0.30,      // 30%使用疑问开头
  "dataHook": 0.25,          // 25%使用数据开头
  "storyHook": 0.20,         // 20%使用故事开头
  "contrastHook": 0.15,      // 15%使用对比开头
  "urgencyHook": 0.05,       // 5%使用紧急开头
  "statementHook": 0.05,     // 5%使用陈述开头
  "examples": {
    "questionHook": ["你知道吗", "有没有想过", "为什么会"],
    "dataHook": ["数据显示", "研究表明", "统计发现"],
    "storyHook": ["昨天遇到", "最近发现", "刚刚看到"],
    "contrastHook": ["很多人以为...但实际上", "传统观点认为...然而"],
    "urgencyHook": ["刚刚", "突发", "最新"]
  }
}
```

### 1.3 分析算法实现

```typescript
// src/server/services/advanced-style-analysis.ts

interface OpeningPatterns {
  questionHook: number;
  dataHook: number;
  storyHook: number;
  contrastHook: number;
  urgencyHook: number;
  statementHook: number;
  examples: Record<string, string[]>;
}

export class AdvancedStyleAnalysisService {

  /**
   * 分析开头模式
   */
  analyzeOpeningPatterns(tweets: Array<{content: string}>): OpeningPatterns {
    const patterns = {
      questionHook: 0,
      dataHook: 0,
      storyHook: 0,
      contrastHook: 0,
      urgencyHook: 0,
      statementHook: 0,
    };

    const examples: Record<string, Set<string>> = {
      questionHook: new Set(),
      dataHook: new Set(),
      storyHook: new Set(),
      contrastHook: new Set(),
      urgencyHook: new Set(),
    };

    tweets.forEach(tweet => {
      const content = tweet.content.trim();
      // 提取开头（前30个字符）
      const opening = content.substring(0, Math.min(30, content.length));

      let matched = false;

      // 1. 疑问开头
      const questionPatterns = [
        /^(你知道|有没有|是否|为什么|如何|怎么|什么是|能不能|可以吗)/,
        /\?$/,  // 开头就是问号结尾
      ];
      if (questionPatterns.some(p => p.test(opening))) {
        patterns.questionHook++;
        const match = opening.match(/^([^，。！？]{2,8})/);
        if (match) examples.questionHook.add(match[1]);
        matched = true;
      }

      // 2. 数据开头
      const dataPatterns = [
        /^(数据显示|研究表明|统计发现|调查显示|报告指出)/,
        /^\d+%/,  // 直接以百分比开头
        /^根据.*?(数据|研究|调查)/,
      ];
      if (!matched && dataPatterns.some(p => p.test(opening))) {
        patterns.dataHook++;
        const match = opening.match(/^([^，。]{2,10})/);
        if (match) examples.dataHook.add(match[1]);
        matched = true;
      }

      // 3. 故事开头
      const storyPatterns = [
        /^(今天|昨天|刚刚|刚才|上周|前几天|最近)/,
        /^(今天|昨天|刚刚|刚才|最近).{0,5}(遇到|发生|看到|听到|发现)/,
      ];
      if (!matched && storyPatterns.some(p => p.test(opening))) {
        patterns.storyHook++;
        const match = opening.match(/^([^，。]{2,10})/);
        if (match) examples.storyHook.add(match[1]);
        matched = true;
      }

      // 4. 对比开头
      const contrastPatterns = [
        /很多人(以为|认为|觉得|说)/,
        /传统(观念|看法|认知)/,
        /(以前|过去).{0,5}(我也|大家都)/,
        /(但是|然而|不过).{0,10}(实际上|其实|事实上)/,
      ];
      if (!matched && contrastPatterns.some(p => p.test(content.substring(0, 50)))) {
        patterns.contrastHook++;
        const match = opening.match(/^([^，。]{2,15})/);
        if (match) examples.contrastHook.add(match[1]);
        matched = true;
      }

      // 5. 紧急开头
      const urgencyPatterns = [
        /^(刚刚|突发|最新|重磅|震惊|注意)/,
        /^！/,
      ];
      if (!matched && urgencyPatterns.some(p => p.test(opening))) {
        patterns.urgencyHook++;
        const match = opening.match(/^([^，。！]{2,8})/);
        if (match) examples.urgencyHook.add(match[1]);
        matched = true;
      }

      // 6. 默认为陈述开头
      if (!matched) {
        patterns.statementHook++;
      }
    });

    // 转换为比例
    const total = tweets.length;
    const result: OpeningPatterns = {
      questionHook: patterns.questionHook / total,
      dataHook: patterns.dataHook / total,
      storyHook: patterns.storyHook / total,
      contrastHook: patterns.contrastHook / total,
      urgencyHook: patterns.urgencyHook / total,
      statementHook: patterns.statementHook / total,
      examples: {
        questionHook: Array.from(examples.questionHook).slice(0, 5),
        dataHook: Array.from(examples.dataHook).slice(0, 5),
        storyHook: Array.from(examples.storyHook).slice(0, 5),
        contrastHook: Array.from(examples.contrastHook).slice(0, 5),
        urgencyHook: Array.from(examples.urgencyHook).slice(0, 5),
      }
    };

    return result;
  }

  /**
   * 保存开头模式到数据库
   */
  async saveOpeningPatterns(username: string, contentType: string, patterns: OpeningPatterns): Promise<void> {
    await db.userStyleProfile.update({
      where: {
        username_contentType: {
          username,
          contentType
        }
      },
      data: {
        openingPatterns: JSON.stringify(patterns)
      }
    });
  }
}
```

### 1.4 在内容生成中的应用

#### 应用场景1：大纲生成阶段

```typescript
async function generateOutlineWithOpeningStyle(task: any): Promise<string> {
  // 1. 加载用户风格档案
  const profile = await db.userStyleProfile.findUnique({
    where: {
      username_contentType: {
        username: task.username,
        contentType: task.contentType
      }
    }
  });

  if (!profile?.openingPatterns) {
    return generateOutline(task); // 回退到默认方式
  }

  // 2. 解析开头模式
  const patterns = JSON.parse(profile.openingPatterns) as OpeningPatterns;

  // 3. 选择最常用的开头模式
  const topPattern = getTopPattern(patterns);

  // 4. 构建开头指令
  const openingInstruction = buildOpeningInstruction(topPattern, patterns);

  const prompt = `
请为以下主题生成文章大纲：

主题：${task.topic}
平台：${task.platform.name}

${openingInstruction}

大纲要求：
1. 开头部分要特别设计，符合用户习惯
2. 包含3-5个主要部分
3. 逻辑连贯
`;

  const aiService = AIServiceFactory.createService({...});
  return await aiService.generateText(prompt);
}

// 获取最常用的开头模式
function getTopPattern(patterns: OpeningPatterns): string {
  const entries = Object.entries(patterns).filter(([key]) => key !== 'examples');
  entries.sort((a, b) => (b[1] as number) - (a[1] as number));
  return entries[0][0];
}

// 构建开头指令
function buildOpeningInstruction(topPattern: string, patterns: OpeningPatterns): string {
  const patternMap: Record<string, string> = {
    questionHook: `
开头策略：使用疑问句开头（用户${(patterns.questionHook * 100).toFixed(0)}%的内容使用此方式）

用户常用的疑问开头示例：
${patterns.examples.questionHook.map((ex, i) => `${i+1}. ${ex}...`).join('\n')}

要求：
- 开头使用引人思考的疑问句
- 可以是反问、设问或直接提问
- 激发读者的好奇心和思考欲望
`,
    dataHook: `
开头策略：使用数据或研究开头（用户${(patterns.dataHook * 100).toFixed(0)}%的内容使用此方式）

用户常用的数据开头示例：
${patterns.examples.dataHook.map((ex, i) => `${i+1}. ${ex}...`).join('\n')}

要求：
- 开头引用具体数据、研究或统计
- 建立权威性和可信度
- 数据要准确、有说服力
`,
    storyHook: `
开头策略：使用故事或案例开头（用户${(patterns.storyHook * 100).toFixed(0)}%的内容使用此方式）

用户常用的故事开头示例：
${patterns.examples.storyHook.map((ex, i) => `${i+1}. ${ex}...`).join('\n')}

要求：
- 开头讲述一个真实或虚构的小故事
- 增强代入感和情感共鸣
- 故事要与主题相关
`,
    contrastHook: `
开头策略：使用对比或反差开头（用户${(patterns.contrastHook * 100).toFixed(0)}%的内容使用此方式）

用户常用的对比开头示例：
${patterns.examples.contrastHook.map((ex, i) => `${i+1}. ${ex}...`).join('\n')}

要求：
- 开头呈现常见误解vs真实情况
- 制造认知反差，引起关注
- "很多人以为...但实际上..."的结构
`,
    urgencyHook: `
开头策略：使用紧急或新闻式开头（用户${(patterns.urgencyHook * 100).toFixed(0)}%的内容使用此方式）

用户常用的紧急开头示例：
${patterns.examples.urgencyHook.map((ex, i) => `${i+1}. ${ex}...`).join('\n')}

要求：
- 开头强调时效性和重要性
- 使用"刚刚"、"最新"、"突发"等词汇
- 营造紧迫感
`,
    statementHook: `
开头策略：使用直接陈述开头（用户${(patterns.statementHook * 100).toFixed(0)}%的内容使用此方式）

要求：
- 开头直接陈述核心观点或事实
- 简洁明了，不绕弯子
- 适合专业性强的内容
`,
  };

  return patternMap[topPattern] || patternMap.statementHook;
}
```

#### 应用场景2：内容生成阶段

```typescript
async function generateContentWithOpeningStyle(
  task: any,
  outline: string
): Promise<string> {
  const profile = await db.userStyleProfile.findUnique({
    where: {
      username_contentType: {
        username: task.username,
        contentType: task.contentType
      }
    }
  });

  const patterns = profile?.openingPatterns
    ? JSON.parse(profile.openingPatterns) as OpeningPatterns
    : null;

  const openingGuide = patterns
    ? `
【开头写作指南】
用户最常用的开头方式：${getTopPattern(patterns)}

具体要求：
${buildOpeningInstruction(getTopPattern(patterns), patterns)}

请在正文开头严格遵循此风格！
`
    : '';

  const prompt = `
基于以下大纲撰写完整文章：

${outline}

${openingGuide}

写作要求：
1. 开头必须符合用户的习惯风格
2. 开头要吸引人，引发兴趣
3. 整体内容连贯完整
`;

  const aiService = AIServiceFactory.createService({...});
  return await aiService.generateText(prompt);
}
```

### 1.5 前端展示

在风格档案页面添加开头模式可视化：

```tsx
// 开头模式分布图
{profile.openingPatterns && (
  <div className="mt-4">
    <h4 className="text-sm font-semibold mb-2">开头模式分布</h4>
    {Object.entries(JSON.parse(profile.openingPatterns))
      .filter(([key]) => key !== 'examples')
      .map(([pattern, ratio]) => (
        <div key={pattern} className="mb-2">
          <div className="flex justify-between text-xs mb-1">
            <span>{patternNameMap[pattern]}</span>
            <span>{((ratio as number) * 100).toFixed(0)}%</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-2">
            <div
              className="bg-indigo-600 h-2 rounded-full"
              style={{ width: `${(ratio as number) * 100}%` }}
            />
          </div>
        </div>
      ))}
  </div>
)}
```

---

## 🎣 功能2：吸引力机制分析

### 2.1 分析目标

量化评估内容的吸引力因素：
- **新颖性**：包含新概念、新数据、新发现
- **争议性**：存在对立观点、批评、质疑
- **实用性**：提供方法、技巧、工具
- **情感共鸣**：引发情感反应
- **认知负担**：理解难度（越低越好）

### 2.2 数据库设计

#### 创建新表：tweet_attraction_analysis
```sql
CREATE TABLE tweet_attraction_analysis (
  id TEXT PRIMARY KEY,
  tweet_id TEXT NOT NULL,
  username TEXT NOT NULL,

  -- 吸引力评分 (0-1)
  novelty_score REAL DEFAULT 0,         -- 新颖性
  controversy_score REAL DEFAULT 0,     -- 争议性
  practicality_score REAL DEFAULT 0,    -- 实用性
  emotional_resonance REAL DEFAULT 0,   -- 情感共鸣
  cognitive_load REAL DEFAULT 0,        -- 认知负担

  -- 综合吸引力分数
  overall_attraction_score REAL DEFAULT 0,

  -- 互动数据（用于验证吸引力）
  like_count INTEGER DEFAULT 0,
  retweet_count INTEGER DEFAULT 0,
  reply_count INTEGER DEFAULT 0,

  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (tweet_id) REFERENCES writing_analysis_tweet(id) ON DELETE CASCADE
);

CREATE INDEX idx_tweet_attraction_username ON tweet_attraction_analysis(username);
CREATE INDEX idx_tweet_attraction_score ON tweet_attraction_analysis(overall_attraction_score DESC);

-- 在 user_style_profile 表中添加平均吸引力特征
ALTER TABLE user_style_profile ADD COLUMN
  attraction_profile TEXT;  -- JSON: 用户的平均吸引力特征

-- 示例数据
{
  "avgNoveltyScore": 0.65,
  "avgControversyScore": 0.30,
  "avgPracticalityScore": 0.75,
  "avgEmotionalResonance": 0.55,
  "avgCognitiveLoad": 0.35,
  "highPerformingFactors": ["practicality", "novelty"],  // 最有效的吸引力因素
  "correlationWithEngagement": 0.72  // 与互动数据的相关性
}
```

### 2.3 分析算法实现

```typescript
interface AttractionScores {
  noveltyScore: number;
  controversyScore: number;
  practicalityScore: number;
  emotionalResonance: number;
  cognitiveLoad: number;
  overallScore: number;
}

export class AdvancedStyleAnalysisService {

  /**
   * 分析单条推文的吸引力
   */
  analyzeAttraction(tweet: {content: string}, engagement?: {
    likeCount: number;
    retweetCount: number;
    replyCount: number;
  }): AttractionScores {
    const content = tweet.content;
    const scores: AttractionScores = {
      noveltyScore: 0,
      controversyScore: 0,
      practicalityScore: 0,
      emotionalResonance: 0,
      cognitiveLoad: 0,
      overallScore: 0,
    };

    // 1. 新颖性分析
    scores.noveltyScore = this.calculateNoveltyScore(content);

    // 2. 争议性分析
    scores.controversyScore = this.calculateControversyScore(content);

    // 3. 实用性分析
    scores.practicalityScore = this.calculatePracticalityScore(content);

    // 4. 情感共鸣分析
    scores.emotionalResonance = this.calculateEmotionalResonance(content);

    // 5. 认知负担分析
    scores.cognitiveLoad = this.calculateCognitiveLoad(content);

    // 6. 计算综合吸引力
    scores.overallScore = this.calculateOverallAttraction(scores);

    return scores;
  }

  /**
   * 计算新颖性分数
   */
  private calculateNoveltyScore(content: string): number {
    let score = 0;

    // 新概念关键词
    const noveltyKeywords = [
      '首次', '最新', '突破', '发现', '新的', '创新',
      '革命性', '颠覆', '前沿', '开创', '首个'
    ];
    noveltyKeywords.forEach(keyword => {
      if (content.includes(keyword)) score += 0.1;
    });

    // 包含具体数据
    if (/\d+%/.test(content)) score += 0.15;
    if (/\d+倍/.test(content)) score += 0.15;

    // 包含时间标记（表示新近发生）
    if (/(今天|昨天|刚刚|最近|本周)/.test(content)) score += 0.1;

    // 包含"研究"、"报告"等权威来源
    if (/(研究|报告|论文|调查).*?(显示|表明|发现|指出)/.test(content)) {
      score += 0.15;
    }

    return Math.min(score, 1.0);
  }

  /**
   * 计算争议性分数
   */
  private calculateControversyScore(content: string): number {
    let score = 0;

    // 对立观点关键词
    const controversyKeywords = [
      '但是', '然而', '不过', '反对', '质疑', '争议',
      '问题', '批评', '不应该', '错误', '误区', '真相'
    ];
    controversyKeywords.forEach(keyword => {
      if (content.includes(keyword)) score += 0.1;
    });

    // 包含对比结构
    if (/(很多人|大家都|传统|以前).{0,10}(认为|觉得|以为)/.test(content)) {
      score += 0.15;
    }
    if (/(但|然而|实际上|其实|事实上)/.test(content)) {
      score += 0.1;
    }

    // 包含否定词
    const negativeWords = ['不', '没', '别', '非', '反', '错'];
    negativeWords.forEach(word => {
      const count = (content.match(new RegExp(word, 'g')) || []).length;
      score += Math.min(count * 0.05, 0.2);
    });

    return Math.min(score, 1.0);
  }

  /**
   * 计算实用性分数
   */
  private calculatePracticalityScore(content: string): number {
    let score = 0;

    // 实用性关键词
    const practicalKeywords = [
      '如何', '方法', '技巧', '工具', '步骤', '攻略',
      '教程', '指南', '秘籍', '实战', '经验', '建议'
    ];
    practicalKeywords.forEach(keyword => {
      if (content.includes(keyword)) score += 0.15;
    });

    // 包含列表结构
    if (/[1-9]\)|[一二三四五]、|第[一二三四五]/.test(content)) {
      score += 0.2;
    }

    // 包含操作性词汇
    const actionWords = ['可以', '应该', '需要', '建议', '推荐', '试试'];
    actionWords.forEach(word => {
      if (content.includes(word)) score += 0.08;
    });

    return Math.min(score, 1.0);
  }

  /**
   * 计算情感共鸣分数
   */
  private calculateEmotionalResonance(content: string): number {
    let score = 0;

    // 第一人称（增强个人连接）
    if (/(我|咱|俺|老子|本人)/.test(content)) {
      const count = (content.match(/(我|咱)/g) || []).length;
      score += Math.min(count * 0.08, 0.25);
    }

    // 第二人称（直接对话）
    if (/(你|您|大家|各位)/.test(content)) {
      score += 0.15;
    }

    // 情感词汇
    const emotionWords = [
      '开心', '高兴', '难过', '感动', '激动', '兴奋',
      '担心', '焦虑', '害怕', '惊讶', '震惊', '意外',
      '喜欢', '讨厌', '爱', '恨', '希望', '失望'
    ];
    emotionWords.forEach(word => {
      if (content.includes(word)) score += 0.08;
    });

    // 感叹号（情感强度）
    const exclamationCount = (content.match(/！|!/g) || []).length;
    score += Math.min(exclamationCount * 0.1, 0.2);

    return Math.min(score, 1.0);
  }

  /**
   * 计算认知负担
   */
  private calculateCognitiveLoad(content: string): number {
    // 句子数量
    const sentences = content.split(/[。！？\n]/).filter(s => s.trim().length > 0);
    const avgSentenceLength = content.length / sentences.length;

    // 句子越长，认知负担越高
    let load = Math.min(avgSentenceLength / 50, 1.0);

    // 专业术语密度（英文单词比例）
    const englishWords = content.match(/[a-zA-Z]+/g) || [];
    const technicalDensity = englishWords.length / (content.length / 10);
    load += Math.min(technicalDensity * 0.5, 0.3);

    // 数字密度
    const numbers = content.match(/\d+/g) || [];
    if (numbers.length > 5) load += 0.2;

    return Math.min(load, 1.0);
  }

  /**
   * 计算综合吸引力分数
   */
  private calculateOverallAttraction(scores: AttractionScores): number {
    // 加权平均（认知负担是负向指标）
    const overall = (
      scores.noveltyScore * 0.25 +
      scores.controversyScore * 0.15 +
      scores.practicalityScore * 0.30 +
      scores.emotionalResonance * 0.20 +
      (1 - scores.cognitiveLoad) * 0.10
    );

    return Math.min(Math.max(overall, 0), 1.0);
  }

  /**
   * 批量分析用户推文的吸引力
   */
  async analyzeUserAttraction(username: string): Promise<void> {
    // 获取用户推文
    const tweets = await db.writingAnalysisTweet.findMany({
      where: { userUsername: username },
      select: {
        id: true,
        content: true,
        likeCount: true,
        retweetCount: true,
        replyCount: true,
      }
    });

    // 分析每条推文
    const analyses = tweets.map(tweet => {
      const scores = this.analyzeAttraction(tweet, {
        likeCount: tweet.likeCount,
        retweetCount: tweet.retweetCount,
        replyCount: tweet.replyCount,
      });

      return {
        tweetId: tweet.id,
        ...scores,
        likeCount: tweet.likeCount,
        retweetCount: tweet.retweetCount,
        replyCount: tweet.replyCount,
      };
    });

    // 保存到数据库
    for (const analysis of analyses) {
      await db.tweetAttractionAnalysis.create({
        data: {
          tweetId: analysis.tweetId,
          username,
          noveltyScore: analysis.noveltyScore,
          controversyScore: analysis.controversyScore,
          practicalityScore: analysis.practicalityScore,
          emotionalResonance: analysis.emotionalResonance,
          cognitiveLoad: analysis.cognitiveLoad,
          overallAttractionScore: analysis.overallScore,
          likeCount: analysis.likeCount,
          retweetCount: analysis.retweetCount,
          replyCount: analysis.replyCount,
        }
      });
    }

    // 计算用户的平均吸引力特征
    await this.calculateUserAttractionProfile(username, analyses);
  }

  /**
   * 计算用户的吸引力档案
   */
  private async calculateUserAttractionProfile(
    username: string,
    analyses: any[]
  ): Promise<void> {
    const avgScores = {
      avgNoveltyScore: this.average(analyses.map(a => a.noveltyScore)),
      avgControversyScore: this.average(analyses.map(a => a.controversyScore)),
      avgPracticalityScore: this.average(analyses.map(a => a.practicalityScore)),
      avgEmotionalResonance: this.average(analyses.map(a => a.emotionalResonance)),
      avgCognitiveLoad: this.average(analyses.map(a => a.cognitiveLoad)),
    };

    // 找出最有效的吸引力因素（与互动数据相关性最高）
    const factors = ['novelty', 'controversy', 'practicality', 'emotional'];
    const correlations = factors.map(factor => ({
      factor,
      correlation: this.calculateCorrelation(
        analyses.map(a => a[`${factor}Score`]),
        analyses.map(a => a.likeCount + a.retweetCount * 2)
      )
    }));
    correlations.sort((a, b) => b.correlation - a.correlation);

    const attractionProfile = {
      ...avgScores,
      highPerformingFactors: correlations.slice(0, 2).map(c => c.factor),
      correlationWithEngagement: correlations[0].correlation,
    };

    // 更新到风格档案（假设已有基础风格档案）
    // 这里需要遍历所有内容类型的档案
    const profiles = await db.userStyleProfile.findMany({
      where: { username }
    });

    for (const profile of profiles) {
      await db.userStyleProfile.update({
        where: { id: profile.id },
        data: {
          attractionProfile: JSON.stringify(attractionProfile)
        }
      });
    }
  }

  private average(numbers: number[]): number {
    return numbers.reduce((a, b) => a + b, 0) / numbers.length;
  }

  private calculateCorrelation(x: number[], y: number[]): number {
    const n = x.length;
    const sumX = x.reduce((a, b) => a + b, 0);
    const sumY = y.reduce((a, b) => a + b, 0);
    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
    const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
    const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);

    const numerator = n * sumXY - sumX * sumY;
    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

    return denominator === 0 ? 0 : numerator / denominator;
  }
}
```

### 2.4 在内容生成中的应用

```typescript
async function generateWithAttractionOptimization(
  task: any,
  outline: string
): Promise<string> {
  // 1. 获取用户的吸引力档案
  const profile = await db.userStyleProfile.findUnique({
    where: {
      username_contentType: {
        username: task.username,
        contentType: task.contentType
      }
    }
  });

  const attractionProfile = profile?.attractionProfile
    ? JSON.parse(profile.attractionProfile)
    : null;

  if (!attractionProfile) {
    return generateContent(task, outline); // 回退
  }

  // 2. 构建吸引力优化指令
  const attractionGuide = `
【内容吸引力优化指南】

基于用户${task.username}的成功经验，以下因素最能提升内容吸引力：

主要吸引力来源：
${attractionProfile.highPerformingFactors.map((factor: string) => {
  const factorMap: Record<string, string> = {
    novelty: '✓ 新颖性（用户平均分: ' + (attractionProfile.avgNoveltyScore * 100).toFixed(0) + '%）\n  - 引入新概念、新数据、新发现\n  - 使用"首次"、"最新"、"突破"等词汇',
    controversy: '✓ 争议性（用户平均分: ' + (attractionProfile.avgControversyScore * 100).toFixed(0) + '%）\n  - 提出不同观点或质疑常见认知\n  - 使用"但是"、"然而"、"真相是"等词汇',
    practicality: '✓ 实用性（用户平均分: ' + (attractionProfile.avgPracticalityScore * 100).toFixed(0) + '%）\n  - 提供具体方法、步骤、工具\n  - 使用"如何"、"技巧"、"攻略"等词汇',
    emotional: '✓ 情感共鸣（用户平均分: ' + (attractionProfile.avgEmotionalResonance * 100).toFixed(0) + '%）\n  - 使用第一人称"我"分享感受\n  - 使用情感词汇和感叹句',
  };
  return factorMap[factor] || '';
}).join('\n\n')}

认知负担控制：
- 用户平均认知负担：${(attractionProfile.avgCognitiveLoad * 100).toFixed(0)}%
- 建议：保持句子简洁${attractionProfile.avgCognitiveLoad < 0.4 ? '（短句为主）' : '（可以使用长句）'}

目标：生成的内容应该在上述高效因素上得分较高！
`;

  const prompt = `
基于以下大纲撰写完整文章：

${outline}

${attractionGuide}

写作要求：
1. 重点强化用户的高效吸引力因素
2. 内容要有吸引力，让人想读下去
3. 保持逻辑连贯和内容质量
`;

  const aiService = AIServiceFactory.createService({...});
  return await aiService.generateText(prompt);
}
```

#### 生成后验证

```typescript
/**
 * 生成内容后，评估吸引力并给出改进建议
 */
async function evaluateGeneratedContent(content: string): Promise<{
  scores: AttractionScores;
  suggestions: string[];
}> {
  const service = new AdvancedStyleAnalysisService();
  const scores = service.analyzeAttraction({ content });

  const suggestions: string[] = [];

  // 根据评分给出建议
  if (scores.noveltyScore < 0.4) {
    suggestions.push('💡 新颖性不足：建议添加最新数据、研究发现或新概念');
  }
  if (scores.practicalityScore < 0.5) {
    suggestions.push('🔧 实用性不足：建议添加具体方法、步骤或工具推荐');
  }
  if (scores.emotionalResonance < 0.3) {
    suggestions.push('❤️ 情感共鸣不足：建议使用第一人称分享感受，增强情感表达');
  }
  if (scores.cognitiveLoad > 0.7) {
    suggestions.push('📖 认知负担过高：建议简化句子，减少专业术语');
  }

  if (scores.overallScore >= 0.7) {
    suggestions.push('✅ 整体吸引力优秀！');
  } else if (scores.overallScore >= 0.5) {
    suggestions.push('✓ 整体吸引力良好，可以进一步优化');
  } else {
    suggestions.push('⚠️ 整体吸引力较低，建议重点改进');
  }

  return { scores, suggestions };
}
```

---

## 🎭 功能3：情绪钩子识别

### 3.1 分析目标

识别用户如何设置情绪触发点：
- **开头钩子**：好奇心缺口、个人故事、数据冲击
- **中间维持钩子**：渐进揭示、意外转折
- **结尾钩子**：行动号召、引发思考

### 3.2 数据库设计

```sql
ALTER TABLE user_style_profile ADD COLUMN
  emotional_hooks TEXT;  -- JSON: 情绪钩子模式

-- 示例数据
{
  "openingHooks": {
    "curiosityGap": {
      "usage": 0.35,  // 使用率35%
      "effectiveness": 0.82,  // 有效性82%
      "examples": ["你知道...但实际上...", "很多人不知道..."]
    },
    "personalStory": {
      "usage": 0.25,
      "effectiveness": 0.75,
      "examples": ["昨天遇到一件事...", "最近发现..."]
    },
    "dataShock": {
      "usage": 0.20,
      "effectiveness": 0.78,
      "examples": ["数据显示竟然有70%...", "研究发现..."]
    }
  },
  "sustainingHooks": {
    "progressiveRevelation": 0.40,  // "更重要的是..."
    "unexpectedTurn": 0.30,         // "但是..."
    "readerInvolvement": 0.20       // "你是否也..."
  },
  "closingHooks": {
    "callToAction": 0.50,           // "你怎么看？"
    "thoughtProvoking": 0.30,       // "这让我们思考..."
    "cliffhanger": 0.20             // "下次分享..."
  }
}
```

### 3.3 分析算法

```typescript
interface EmotionalHooks {
  openingHooks: {
    curiosityGap: { usage: number; effectiveness: number; examples: string[] };
    personalStory: { usage: number; effectiveness: number; examples: string[] };
    dataShock: { usage: number; effectiveness: number; examples: string[] };
  };
  sustainingHooks: {
    progressiveRevelation: number;
    unexpectedTurn: number;
    readerInvolvement: number;
  };
  closingHooks: {
    callToAction: number;
    thoughtProvoking: number;
    cliffhanger: number;
  };
}

export class AdvancedStyleAnalysisService {

  /**
   * 识别情绪钩子
   */
  analyzeEmotionalHooks(tweets: Array<{
    content: string;
    likeCount: number;
    retweetCount: number;
  }>): EmotionalHooks {

    const hooks: EmotionalHooks = {
      openingHooks: {
        curiosityGap: { usage: 0, effectiveness: 0, examples: [] },
        personalStory: { usage: 0, effectiveness: 0, examples: [] },
        dataShock: { usage: 0, effectiveness: 0, examples: [] },
      },
      sustainingHooks: {
        progressiveRevelation: 0,
        unexpectedTurn: 0,
        readerInvolvement: 0,
      },
      closingHooks: {
        callToAction: 0,
        thoughtProvoking: 0,
        cliffhanger: 0,
      }
    };

    const openingExamples = {
      curiosityGap: [] as Array<{text: string, engagement: number}>,
      personalStory: [] as Array<{text: string, engagement: number}>,
      dataShock: [] as Array<{text: string, engagement: number}>,
    };

    tweets.forEach(tweet => {
      const content = tweet.content;
      const opening = content.substring(0, 50);
      const ending = content.substring(Math.max(0, content.length - 50));
      const engagement = tweet.likeCount + tweet.retweetCount * 2;

      // 1. 开头钩子识别

      // 好奇心缺口
      if (/(你知道|有没有想过|很多人不知道).*?(但|其实|实际上)/.test(opening)) {
        hooks.openingHooks.curiosityGap.usage++;
        openingExamples.curiosityGap.push({
          text: opening.substring(0, 30),
          engagement
        });
      }

      // 个人故事
      if (/(昨天|今天|最近|上周).{0,5}(遇到|发生|看到|听到|发现)/.test(opening)) {
        hooks.openingHooks.personalStory.usage++;
        openingExamples.personalStory.push({
          text: opening.substring(0, 30),
          engagement
        });
      }

      // 数据冲击
      if (/(数据显示|研究表明|统计发现).*?(\d+%|竟然|居然)/.test(opening)) {
        hooks.openingHooks.dataShock.usage++;
        openingExamples.dataShock.push({
          text: opening.substring(0, 30),
          engagement
        });
      }

      // 2. 中间维持钩子

      // 渐进揭示
      if (/(更重要的是|还有|另外|此外|而且)/.test(content)) {
        hooks.sustainingHooks.progressiveRevelation++;
      }

      // 意外转折
      if (/(但是|然而|不过|可是|却)/.test(content)) {
        hooks.sustainingHooks.unexpectedTurn++;
      }

      // 读者卷入
      if (/(你是否|你有没有|你会不会|想象一下)/.test(content)) {
        hooks.sustainingHooks.readerInvolvement++;
      }

      // 3. 结尾钩子

      // 行动号召
      if (/(你怎么看|欢迎讨论|欢迎留言|说说你的看法)/.test(ending)) {
        hooks.closingHooks.callToAction++;
      }

      // 引发思考
      if (/(这让我们|值得我们|应该让我们).{0,5}(思考|反思|警醒)/.test(ending)) {
        hooks.closingHooks.thoughtProvoking++;
      }

      // 悬念
      if (/(下次|下期|未完待续|敬请期待|待续)/.test(ending)) {
        hooks.closingHooks.cliffhanger++;
      }
    });

    // 转换为比例并计算有效性
    const total = tweets.length;

    // 开头钩子
    ['curiosityGap', 'personalStory', 'dataShock'].forEach(hookType => {
      const hook = hooks.openingHooks[hookType as keyof typeof hooks.openingHooks];
      hook.usage = hook.usage / total;

      // 计算有效性（使用此钩子的推文的平均互动数 / 所有推文的平均互动数）
      const examples = openingExamples[hookType as keyof typeof openingExamples];
      if (examples.length > 0) {
        const avgEngagement = examples.reduce((sum, e) => sum + e.engagement, 0) / examples.length;
        const totalAvgEngagement = tweets.reduce((sum, t) => sum + (t.likeCount + t.retweetCount * 2), 0) / total;
        hook.effectiveness = totalAvgEngagement > 0 ? Math.min(avgEngagement / totalAvgEngagement, 1.0) : 0;

        // 保存效果最好的例子
        examples.sort((a, b) => b.engagement - a.engagement);
        hook.examples = examples.slice(0, 3).map(e => e.text);
      }
    });

    // 中间钩子和结尾钩子（转换为比例）
    Object.keys(hooks.sustainingHooks).forEach(key => {
      hooks.sustainingHooks[key as keyof typeof hooks.sustainingHooks] /= total;
    });
    Object.keys(hooks.closingHooks).forEach(key => {
      hooks.closingHooks[key as keyof typeof hooks.closingHooks] /= total;
    });

    return hooks;
  }
}
```

### 3.4 在内容生成中的应用

```typescript
async function generateWithEmotionalHooks(
  task: any,
  outline: string
): Promise<string> {
  const profile = await db.userStyleProfile.findUnique({
    where: {
      username_contentType: {
        username: task.username,
        contentType: task.contentType
      }
    }
  });

  const emotionalHooks = profile?.emotionalHooks
    ? JSON.parse(profile.emotionalHooks) as EmotionalHooks
    : null;

  if (!emotionalHooks) {
    return generateContent(task, outline);
  }

  // 选择最有效的开头钩子
  const topOpeningHook = Object.entries(emotionalHooks.openingHooks)
    .sort(([,a], [,b]) => b.effectiveness - a.effectiveness)[0];

  const hookGuide = `
【情绪钩子设计指南】

用户${task.username}最有效的开头钩子：${topOpeningHook[0]}
（有效性：${(topOpeningHook[1].effectiveness * 100).toFixed(0)}%）

示例：
${topOpeningHook[1].examples.map((ex: string, i: number) => `${i+1}. ${ex}...`).join('\n')}

中间维持技巧（用户使用频率）：
${emotionalHooks.sustainingHooks.progressiveRevelation > 0.3 ? '✓ 渐进揭示："更重要的是..."、"还有..."（' + (emotionalHooks.sustainingHooks.progressiveRevelation * 100).toFixed(0) + '%）\n' : ''}
${emotionalHooks.sustainingHooks.unexpectedTurn > 0.2 ? '✓ 意外转折："但是..."、"然而..."（' + (emotionalHooks.sustainingHooks.unexpectedTurn * 100).toFixed(0) + '%）\n' : ''}
${emotionalHooks.sustainingHooks.readerInvolvement > 0.15 ? '✓ 读者卷入："你是否也..."、"想象一下..."（' + (emotionalHooks.sustainingHooks.readerInvolvement * 100).toFixed(0) + '%）\n' : ''}

结尾钩子（用户最常用）：
${Object.entries(emotionalHooks.closingHooks)
  .sort(([,a], [,b]) => (b as number) - (a as number))[0]?.[0] === 'callToAction' ? '✓ 行动号召："你怎么看？"、"欢迎讨论"' :
  Object.entries(emotionalHooks.closingHooks).sort(([,a], [,b]) => (b as number) - (a as number))[0]?.[0] === 'thoughtProvoking' ? '✓ 引发思考："这让我们思考..."' :
  '✓ 悬念结尾："下次分享..."'}

设计要求：
1. 开头必须使用用户最有效的钩子类型
2. 中间适当使用维持钩子，保持读者兴趣
3. 结尾使用用户习惯的钩子类型
`;

  const prompt = `
基于以下大纲撰写完整文章：

${outline}

${hookGuide}

写作要求：
1. 严格按照情绪钩子指南设计内容结构
2. 开头要吸引人，中间要维持兴趣，结尾要有冲击力
3. 整体保持连贯和自然
`;

  const aiService = AIServiceFactory.createService({...});
  return await aiService.generateText(prompt);
}
```

---

## 📝 功能4：句式模板提取

### 4.1 分析目标

提取用户高频使用的句子结构模板，用于：
- 内容生成时的句式参考
- 保持用户独特的表达习惯
- 构建个性化的句式库

### 4.2 数据库设计

```sql
-- 句式模板库
CREATE TABLE sentence_templates (
  id TEXT PRIMARY KEY,
  username TEXT NOT NULL,
  template_pattern TEXT NOT NULL,     -- 句式模板
  frequency INTEGER DEFAULT 1,        -- 使用频率
  category TEXT,                      -- 类别：opening/development/closing
  emotion_type TEXT,                  -- 情感类型：neutral/positive/negative
  avg_engagement REAL DEFAULT 0,      -- 平均互动数
  examples TEXT,                      -- JSON: 实际例子
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_sentence_templates_username ON sentence_templates(username);
CREATE INDEX idx_sentence_templates_frequency ON sentence_templates(frequency DESC);
CREATE INDEX idx_sentence_templates_category ON sentence_templates(category);

-- 在 user_style_profile 中添加摘要字段
ALTER TABLE user_style_profile ADD COLUMN
  sentence_templates_summary TEXT;  -- JSON: 高频模板摘要

-- 示例数据
{
  "topTemplates": [
    {
      "pattern": "[PERSON]觉得[THING][ADJ]",
      "frequency": 15,
      "examples": ["我觉得这个技术很有潜力", "大家觉得这个方案不错"]
    },
    {
      "pattern": "[THING]的[ASPECT]非常[ADJ]",
      "frequency": 12,
      "examples": ["AI的发展非常迅速", "技术的应用非常广泛"]
    }
  ],
  "totalTemplates": 50
}
```

### 4.3 分析算法

```typescript
interface SentenceTemplate {
  pattern: string;        // 模板模式
  frequency: number;      // 频率
  category: string;       // 类别
  emotionType: string;    // 情感类型
  examples: string[];     // 例子
}

export class AdvancedStyleAnalysisService {

  /**
   * 提取句式模板
   */
  extractSentenceTemplates(tweets: Array<{
    content: string;
    likeCount: number;
    retweetCount: number;
  }>): SentenceTemplate[] {

    const templateMap = new Map<string, {
      count: number;
      examples: Array<{text: string, engagement: number}>;
      category: string;
      emotionType: string;
    }>();

    tweets.forEach(tweet => {
      const sentences = this.splitIntoSentences(tweet.content);
      const engagement = tweet.likeCount + tweet.retweetCount * 2;

      sentences.forEach((sentence, index) => {
        // 提取模板
        const template = this.extractTemplatePattern(sentence);

        if (template && sentence.length >= 5 && sentence.length <= 100) {
          // 判断类别
          const category = index === 0 ? 'opening' :
                          index === sentences.length - 1 ? 'closing' :
                          'development';

          // 判断情感类型
          const emotionType = this.detectEmotionType(sentence);

          if (!templateMap.has(template)) {
            templateMap.set(template, {
              count: 0,
              examples: [],
              category,
              emotionType,
            });
          }

          const entry = templateMap.get(template)!;
          entry.count++;
          entry.examples.push({ text: sentence, engagement });
        }
      });
    });

    // 转换为数组并排序
    const templates: SentenceTemplate[] = [];

    templateMap.forEach((value, pattern) => {
      // 只保留出现3次以上的模板
      if (value.count >= 3) {
        // 选择互动最高的3个例子
        value.examples.sort((a, b) => b.engagement - a.engagement);

        templates.push({
          pattern,
          frequency: value.count,
          category: value.category,
          emotionType: value.emotionType,
          examples: value.examples.slice(0, 3).map(e => e.text),
        });
      }
    });

    // 按频率排序
    templates.sort((a, b) => b.frequency - a.frequency);

    return templates.slice(0, 50); // 保留前50个
  }

  /**
   * 将文本分割为句子
   */
  private splitIntoSentences(text: string): string[] {
    return text
      .split(/[。！？\n]/)
      .map(s => s.trim())
      .filter(s => s.length > 0);
  }

  /**
   * 提取模板模式
   */
  private extractTemplatePattern(sentence: string): string {
    let template = sentence;

    // 1. 替换数字 → [NUM]
    template = template.replace(/\d+/g, '[NUM]');

    // 2. 替换英文 → [ENG]
    template = template.replace(/[a-zA-Z]+/g, '[ENG]');

    // 3. 替换常见专业术语 → [TECH]
    const techTerms = ['AI', '机器学习', '深度学习', '区块链', '算法', '模型', '数据', '技术'];
    techTerms.forEach(term => {
      template = template.replace(new RegExp(term, 'g'), '[TECH]');
    });

    // 4. 替换时间词 → [TIME]
    const timeWords = ['今天', '昨天', '明天', '最近', '以前', '现在', '未来'];
    timeWords.forEach(word => {
      template = template.replace(new RegExp(word, 'g'), '[TIME]');
    });

    // 5. 替换人称 → [PERSON]
    const persons = ['我', '你', '他', '她', '我们', '大家', '用户'];
    persons.forEach(word => {
      template = template.replace(new RegExp(word, 'g'), '[PERSON]');
    });

    // 6. 替换形容词 → [ADJ]
    const adjectives = ['好', '坏', '大', '小', '多', '少', '高', '低', '快', '慢', '强', '弱', '重要', '有趣', '有用'];
    adjectives.forEach(word => {
      template = template.replace(new RegExp(word, 'g'), '[ADJ]');
    });

    // 7. 替换抽象概念 → [THING]
    // 保留句子结构和功能词，但将实体名词抽象化
    // 这里简化处理，检测常见模式
    if (/的/.test(template)) {
      template = template.replace(/([^的]{2,8})的/g, '[THING]的');
    }

    return template;
  }

  /**
   * 检测情感类型
   */
  private detectEmotionType(sentence: string): string {
    const positiveWords = ['好', '棒', '优秀', '成功', '喜欢', '开心', '希望', '不错'];
    const negativeWords = ['坏', '差', '失败', '问题', '担心', '难', '不行'];

    const hasPositive = positiveWords.some(word => sentence.includes(word));
    const hasNegative = negativeWords.some(word => sentence.includes(word));

    if (hasPositive && !hasNegative) return 'positive';
    if (hasNegative && !hasPositive) return 'negative';
    return 'neutral';
  }

  /**
   * 保存句式模板到数据库
   */
  async saveSentenceTemplates(username: string, templates: SentenceTemplate[]): Promise<void> {
    // 删除旧模板
    await db.sentenceTemplate.deleteMany({
      where: { username }
    });

    // 保存新模板
    for (const template of templates) {
      await db.sentenceTemplate.create({
        data: {
          username,
          templatePattern: template.pattern,
          frequency: template.frequency,
          category: template.category,
          emotionType: template.emotionType,
          examples: JSON.stringify(template.examples),
        }
      });
    }

    // 更新风格档案摘要
    const topTemplates = templates.slice(0, 10).map(t => ({
      pattern: t.pattern,
      frequency: t.frequency,
      examples: t.examples.slice(0, 2),
    }));

    // 更新所有内容类型的档案
    await db.userStyleProfile.updateMany({
      where: { username },
      data: {
        sentenceTemplatesSummary: JSON.stringify({
          topTemplates,
          totalTemplates: templates.length,
        })
      }
    });
  }
}
```

### 4.4 在内容生成中的应用

```typescript
async function generateWithSentenceTemplates(
  task: any,
  outline: string
): Promise<string> {
  // 1. 获取用户的句式模板
  const templates = await db.sentenceTemplate.findMany({
    where: { username: task.username },
    orderBy: { frequency: 'desc' },
    take: 10,
  });

  if (templates.length === 0) {
    return generateContent(task, outline);
  }

  // 2. 构建句式参考
  const templateGuide = `
【句式风格参考】

用户${task.username}的高频句式模板：

开头常用句式：
${templates
  .filter(t => t.category === 'opening')
  .slice(0, 3)
  .map((t, i) => {
    const examples = JSON.parse(t.examples);
    return `${i+1}. 模板：${t.templatePattern}\n   示例：${examples[0]}`;
  })
  .join('\n\n')}

正文常用句式：
${templates
  .filter(t => t.category === 'development')
  .slice(0, 5)
  .map((t, i) => {
    const examples = JSON.parse(t.examples);
    return `${i+1}. 模板：${t.templatePattern}\n   示例：${examples[0]}`;
  })
  .join('\n\n')}

写作要求：
1. 参考以上句式模板，模仿用户的表达习惯
2. 不要生硬套用，要自然融入内容
3. 保持句式的多样性，适当变化
`;

  const prompt = `
基于以下大纲撰写完整文章：

${outline}

${templateGuide}

注意：参考用户的句式习惯，但要根据具体内容灵活运用。
`;

  const aiService = AIServiceFactory.createService({...});
  return await aiService.generateText(prompt);
}
```

---

## 🎨 功能5：叙述风格分析

### 5.1 分析目标

深度分析用户的叙述偏好：
- **故事性**：个人轶事、时间顺序、人物塑造
- **说服性**：逻辑论证、证据支持、情感诉求
- **互动性**：直接称呼、提问互动、对话语调
- **权威性**：专业展示、自信程度、引用使用

### 5.2 数据库设计

```sql
ALTER TABLE user_style_profile ADD COLUMN
  narrative_style TEXT;  -- JSON: 叙述风格特征

-- 示例数据
{
  "storytelling": {
    "usePersonalAnecdotes": 0.40,      // 40%使用个人故事
    "chronologicalOrder": 0.55,        // 55%使用时间顺序
    "characterDevelopment": 0.25       // 25%有人物塑造
  },
  "persuasion": {
    "logicalArgument": 0.65,           // 65%使用逻辑论证
    "evidenceSupport": 0.50,           // 50%提供证据支持
    "emotionalAppeal": 0.35            // 35%使用情感诉求
  },
  "interaction": {
    "directAddress": 0.60,             // 60%直接称呼读者
    "questionEngagement": 0.45,        // 45%使用提问互动
    "conversationalTone": 0.70         // 70%使用对话语调
  },
  "authority": {
    "expertiseDisplay": 0.55,          // 55%展示专业知识
    "confidenceLevel": 0.75,           // 75%语气自信
    "citationUsage": 0.30              // 30%使用引用
  },
  "dominantStyle": "persuasion"        // 主导风格
}
```

### 5.3 分析算法

```typescript
interface NarrativeStyle {
  storytelling: {
    usePersonalAnecdotes: number;
    chronologicalOrder: number;
    characterDevelopment: number;
  };
  persuasion: {
    logicalArgument: number;
    evidenceSupport: number;
    emotionalAppeal: number;
  };
  interaction: {
    directAddress: number;
    questionEngagement: number;
    conversationalTone: number;
  };
  authority: {
    expertiseDisplay: number;
    confidenceLevel: number;
    citationUsage: number;
  };
  dominantStyle: string;
}

export class AdvancedStyleAnalysisService {

  /**
   * 分析叙述风格
   */
  analyzeNarrativeStyle(tweets: Array<{content: string}>): NarrativeStyle {
    const style: NarrativeStyle = {
      storytelling: {
        usePersonalAnecdotes: 0,
        chronologicalOrder: 0,
        characterDevelopment: 0,
      },
      persuasion: {
        logicalArgument: 0,
        evidenceSupport: 0,
        emotionalAppeal: 0,
      },
      interaction: {
        directAddress: 0,
        questionEngagement: 0,
        conversationalTone: 0,
      },
      authority: {
        expertiseDisplay: 0,
        confidenceLevel: 0,
        citationUsage: 0,
      },
      dominantStyle: '',
    };

    tweets.forEach(tweet => {
      const content = tweet.content;

      // 1. 故事性分析

      // 个人轶事
      if (/(我|咱).{0,5}(遇到|经历|发现|看到|听到)/.test(content)) {
        style.storytelling.usePersonalAnecdotes++;
      }

      // 时间顺序
      if (/(首先|然后|接着|最后|之后|后来|再后来)/.test(content)) {
        style.storytelling.chronologicalOrder++;
      }

      // 人物塑造（描述人物特征、行为）
      if (/(他|她|这个人|那个人).{0,10}(说|做|想|认为)/.test(content)) {
        style.storytelling.characterDevelopment++;
      }

      // 2. 说服性分析

      // 逻辑论证
      if (/(因为|所以|因此|由于|既然|那么)/.test(content)) {
        style.persuasion.logicalArgument++;
      }

      // 证据支持
      if (/(数据|研究|报告|统计|调查|事实|证明|表明)/.test(content)) {
        style.persuasion.evidenceSupport++;
      }

      // 情感诉求
      if (/(感动|震惊|担心|希望|相信|梦想|害怕)/.test(content)) {
        style.persuasion.emotionalAppeal++;
      }

      // 3. 互动性分析

      // 直接称呼
      if (/(你|您|大家|各位|朋友们)/.test(content)) {
        style.interaction.directAddress++;
      }

      // 提问互动
      const questionCount = (content.match(/[？?]/g) || []).length;
      if (questionCount > 0) {
        style.interaction.questionEngagement++;
      }

      // 对话语调（口语化表达）
      if (/(嘛|呢|啦|哦|哈|吧|呀|咯)/.test(content)) {
        style.interaction.conversationalTone++;
      }

      // 4. 权威性分析

      // 专业知识展示（使用专业术语）
      const techCount = (content.match(/[a-zA-Z]{3,}/g) || []).length;
      if (techCount >= 3) {
        style.authority.expertiseDisplay++;
      }

      // 自信程度（使用断言性词汇）
      if (/(必须|一定|肯定|显然|毫无疑问|毋庸置疑|确实)/.test(content)) {
        style.authority.confidenceLevel++;
      }

      // 引用使用
      if (/(根据|引用|来自|出自|[《""''])/.test(content)) {
        style.authority.citationUsage++;
      }
    });

    // 转换为比例
    const total = tweets.length;

    Object.keys(style.storytelling).forEach(key => {
      style.storytelling[key as keyof typeof style.storytelling] /= total;
    });
    Object.keys(style.persuasion).forEach(key => {
      style.persuasion[key as keyof typeof style.persuasion] /= total;
    });
    Object.keys(style.interaction).forEach(key => {
      style.interaction[key as keyof typeof style.interaction] /= total;
    });
    Object.keys(style.authority).forEach(key => {
      style.authority[key as keyof typeof style.authority] /= total;
    });

    // 确定主导风格
    const styleScores = {
      storytelling: this.average(Object.values(style.storytelling)),
      persuasion: this.average(Object.values(style.persuasion)),
      interaction: this.average(Object.values(style.interaction)),
      authority: this.average(Object.values(style.authority)),
    };

    style.dominantStyle = Object.entries(styleScores)
      .sort(([,a], [,b]) => b - a)[0][0];

    return style;
  }

  private average(numbers: number[]): number {
    return numbers.reduce((a, b) => a + b, 0) / numbers.length;
  }
}
```

### 5.4 在内容生成中的应用

```typescript
async function generateWithNarrativeStyle(
  task: any,
  outline: string
): Promise<string> {
  const profile = await db.userStyleProfile.findUnique({
    where: {
      username_contentType: {
        username: task.username,
        contentType: task.contentType
      }
    }
  });

  const narrativeStyle = profile?.narrativeStyle
    ? JSON.parse(profile.narrativeStyle) as NarrativeStyle
    : null;

  if (!narrativeStyle) {
    return generateContent(task, outline);
  }

  // 根据主导风格构建指令
  const styleGuide = buildNarrativeStyleGuide(narrativeStyle);

  const prompt = `
基于以下大纲撰写完整文章：

${outline}

${styleGuide}

写作要求：
1. 严格遵循用户的叙述风格特征
2. 保持风格的一致性
3. 内容充实，逻辑连贯
`;

  const aiService = AIServiceFactory.createService({...});
  return await aiService.generateText(prompt);
}

function buildNarrativeStyleGuide(style: NarrativeStyle): string {
  const guide: string[] = [
    `【叙述风格指南】`,
    ``,
    `用户的主导叙述风格：${style.dominantStyle === 'storytelling' ? '故事性' :
                              style.dominantStyle === 'persuasion' ? '说服性' :
                              style.dominantStyle === 'interaction' ? '互动性' : '权威性'}`,
    ``,
  ];

  // 故事性
  if (style.storytelling.usePersonalAnecdotes > 0.3) {
    guide.push(`✓ 故事性（高）：`);
    if (style.storytelling.usePersonalAnecdotes > 0.3) {
      guide.push(`  - 经常使用个人故事和经历（${(style.storytelling.usePersonalAnecdotes * 100).toFixed(0)}%）`);
      guide.push(`  - 多用"我遇到..."、"我发现..."等第一人称叙述`);
    }
    if (style.storytelling.chronologicalOrder > 0.4) {
      guide.push(`  - 喜欢按时间顺序叙述（${(style.storytelling.chronologicalOrder * 100).toFixed(0)}%）`);
      guide.push(`  - 使用"首先...然后...最后..."的结构`);
    }
    guide.push(``);
  }

  // 说服性
  if (style.persuasion.logicalArgument > 0.5) {
    guide.push(`✓ 说服性（高）：`);
    if (style.persuasion.logicalArgument > 0.5) {
      guide.push(`  - 强调逻辑论证（${(style.persuasion.logicalArgument * 100).toFixed(0)}%）`);
      guide.push(`  - 多使用"因为...所以..."、"由于...因此..."的逻辑连接`);
    }
    if (style.persuasion.evidenceSupport > 0.4) {
      guide.push(`  - 注重证据支持（${(style.persuasion.evidenceSupport * 100).toFixed(0)}%）`);
      guide.push(`  - 引用数据、研究、统计来支撑观点`);
    }
    if (style.persuasion.emotionalAppeal > 0.3) {
      guide.push(`  - 适度使用情感诉求（${(style.persuasion.emotionalAppeal * 100).toFixed(0)}%）`);
    }
    guide.push(``);
  }

  // 互动性
  if (style.interaction.directAddress > 0.5) {
    guide.push(`✓ 互动性（高）：`);
    if (style.interaction.directAddress > 0.5) {
      guide.push(`  - 经常直接称呼读者（${(style.interaction.directAddress * 100).toFixed(0)}%）`);
      guide.push(`  - 多使用"你"、"大家"等第二人称`);
    }
    if (style.interaction.questionEngagement > 0.3) {
      guide.push(`  - 频繁使用提问互动（${(style.interaction.questionEngagement * 100).toFixed(0)}%）`);
      guide.push(`  - 适时抛出问题引导思考`);
    }
    if (style.interaction.conversationalTone > 0.6) {
      guide.push(`  - 使用对话语调（${(style.interaction.conversationalTone * 100).toFixed(0)}%）`);
      guide.push(`  - 语气轻松，像朋友聊天一样`);
    }
    guide.push(``);
  }

  // 权威性
  if (style.authority.expertiseDisplay > 0.4) {
    guide.push(`✓ 权威性（高）：`);
    if (style.authority.expertiseDisplay > 0.4) {
      guide.push(`  - 展示专业知识（${(style.authority.expertiseDisplay * 100).toFixed(0)}%）`);
      guide.push(`  - 适当使用专业术语展示深度`);
    }
    if (style.authority.confidenceLevel > 0.6) {
      guide.push(`  - 语气自信坚定（${(style.authority.confidenceLevel * 100).toFixed(0)}%）`);
      guide.push(`  - 使用"必须"、"显然"、"毫无疑问"等断言性词汇`);
    }
    if (style.authority.citationUsage > 0.2) {
      guide.push(`  - 适度引用权威来源（${(style.authority.citationUsage * 100).toFixed(0)}%）`);
    }
    guide.push(``);
  }

  return guide.join('\n');
}
```

---

## 🔄 集成流程

### 完整的分析流程

```typescript
/**
 * 执行完整的进阶风格分析
 */
async function performAdvancedStyleAnalysis(username: string): Promise<void> {
  const service = new AdvancedStyleAnalysisService();

  // 1. 获取用户推文
  const tweets = await db.writingAnalysisTweet.findMany({
    where: { userUsername: username },
    select: {
      id: true,
      content: true,
      likeCount: true,
      retweetCount: true,
      replyCount: true,
    }
  });

  if (tweets.length < 10) {
    throw new Error('推文数量不足，需要至少10条');
  }

  // 2. 按内容类型分组
  const typeAnnotations = await db.tweetTypeAnnotation.findMany({
    where: { username }
  });

  const tweetsByType = new Map<string, typeof tweets>();

  tweets.forEach(tweet => {
    const annotation = typeAnnotations.find(a => a.tweetId === tweet.id);
    if (annotation) {
      const types = JSON.parse(annotation.tweetTypes);
      const mainType = Object.entries(types)
        .sort(([,a], [,b]) => (b as number) - (a as number))[0][0];

      if (!tweetsByType.has(mainType)) {
        tweetsByType.set(mainType, []);
      }
      tweetsByType.get(mainType)!.push(tweet);
    }
  });

  // 3. 对每个内容类型进行进阶分析
  for (const [contentType, typeTweets] of tweetsByType) {
    if (typeTweets.length < 5) continue; // 样本不足跳过

    console.log(`分析用户 ${username} 的 ${contentType} 类型...`);

    // 3.1 开头模式识别
    const openingPatterns = service.analyzeOpeningPatterns(typeTweets);

    // 3.2 吸引力分析
    await service.analyzeUserAttraction(username);

    // 3.3 情绪钩子识别
    const emotionalHooks = service.analyzeEmotionalHooks(typeTweets);

    // 3.4 句式模板提取
    const sentenceTemplates = service.extractSentenceTemplates(typeTweets);
    await service.saveSentenceTemplates(username, sentenceTemplates);

    // 3.5 叙述风格分析
    const narrativeStyle = service.analyzeNarrativeStyle(typeTweets);

    // 4. 保存到数据库
    await db.userStyleProfile.update({
      where: {
        username_contentType: {
          username,
          contentType
        }
      },
      data: {
        openingPatterns: JSON.stringify(openingPatterns),
        emotionalHooks: JSON.stringify(emotionalHooks),
        narrativeStyle: JSON.stringify(narrativeStyle),
        updatedAt: new Date(),
      }
    });

    console.log(`✓ ${contentType} 类型分析完成`);
  }

  console.log(`用户 ${username} 的进阶风格分析全部完成！`);
}
```

### API 路由

```typescript
// POST /api/writing-analysis/advanced-style-analysis
export async function POST(request: NextRequest) {
  try {
    const { username } = await request.json();

    if (!username) {
      return NextResponse.json(
        { success: false, error: 'Username is required' },
        { status: 400 }
      );
    }

    // 执行进阶分析
    await performAdvancedStyleAnalysis(username);

    return NextResponse.json({
      success: true,
      message: '进阶风格分析完成',
      data: { username }
    });

  } catch (error) {
    console.error('进阶风格分析失败:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : '未知错误'
      },
      { status: 500 }
    );
  }
}
```

---

## 📊 前端展示界面

### 在风格档案页面添加进阶特征展示

```tsx
// 进阶特征展示组件
function AdvancedStyleFeatures({ profile }: { profile: UserStyleProfile }) {
  const [expandedSections, setExpandedSections] = useState<string[]>([]);

  const toggleSection = (section: string) => {
    setExpandedSections(prev =>
      prev.includes(section)
        ? prev.filter(s => s !== section)
        : [...prev, section]
    );
  };

  return (
    <div className="space-y-4">
      {/* 开头模式 */}
      {profile.openingPatterns && (
        <div className="border rounded-lg overflow-hidden">
          <button
            onClick={() => toggleSection('opening')}
            className="w-full px-4 py-3 bg-gray-50 flex justify-between items-center hover:bg-gray-100"
          >
            <span className="font-medium">🎯 开头模式分布</span>
            <span>{expandedSections.includes('opening') ? '▼' : '▶'}</span>
          </button>

          {expandedSections.includes('opening') && (
            <div className="p-4">
              <OpeningPatternsVisualization data={JSON.parse(profile.openingPatterns)} />
            </div>
          )}
        </div>
      )}

      {/* 吸引力特征 */}
      {profile.attractionProfile && (
        <div className="border rounded-lg overflow-hidden">
          <button
            onClick={() => toggleSection('attraction')}
            className="w-full px-4 py-3 bg-gray-50 flex justify-between items-center hover:bg-gray-100"
          >
            <span className="font-medium">💡 吸引力特征</span>
            <span>{expandedSections.includes('attraction') ? '▼' : '▶'}</span>
          </button>

          {expandedSections.includes('attraction') && (
            <div className="p-4">
              <AttractionProfileVisualization data={JSON.parse(profile.attractionProfile)} />
            </div>
          )}
        </div>
      )}

      {/* 情绪钩子 */}
      {profile.emotionalHooks && (
        <div className="border rounded-lg overflow-hidden">
          <button
            onClick={() => toggleSection('hooks')}
            className="w-full px-4 py-3 bg-gray-50 flex justify-between items-center hover:bg-gray-100"
          >
            <span className="font-medium">🎣 情绪钩子模式</span>
            <span>{expandedSections.includes('hooks') ? '▼' : '▶'}</span>
          </button>

          {expandedSections.includes('hooks') && (
            <div className="p-4">
              <EmotionalHooksVisualization data={JSON.parse(profile.emotionalHooks)} />
            </div>
          )}
        </div>
      )}

      {/* 叙述风格 */}
      {profile.narrativeStyle && (
        <div className="border rounded-lg overflow-hidden">
          <button
            onClick={() => toggleSection('narrative')}
            className="w-full px-4 py-3 bg-gray-50 flex justify-between items-center hover:bg-gray-100"
          >
            <span className="font-medium">🎨 叙述风格特征</span>
            <span>{expandedSections.includes('narrative') ? '▼' : '▶'}</span>
          </button>

          {expandedSections.includes('narrative') && (
            <div className="p-4">
              <NarrativeStyleVisualization data={JSON.parse(profile.narrativeStyle)} />
            </div>
          )}
        </div>
      )}

      {/* 句式模板 */}
      {profile.sentenceTemplatesSummary && (
        <div className="border rounded-lg overflow-hidden">
          <button
            onClick={() => toggleSection('templates')}
            className="w-full px-4 py-3 bg-gray-50 flex justify-between items-center hover:bg-gray-100"
          >
            <span className="font-medium">📝 高频句式模板</span>
            <span>{expandedSections.includes('templates') ? '▼' : '▶'}</span>
          </button>

          {expandedSections.includes('templates') && (
            <div className="p-4">
              <SentenceTemplatesVisualization data={JSON.parse(profile.sentenceTemplatesSummary)} />
            </div>
          )}
        </div>
      )}
    </div>
  );
}
```

---

## 📈 效果预期

实施这5个进阶功能后：

1. **开头模式识别** → 生成的内容开头更吸引人，符合用户习惯
2. **吸引力分析** → 可以预测和优化内容质量，提高互动率
3. **情绪钩子识别** → 内容更有感染力，读者更愿意读完
4. **句式模板提取** → 生成的文字更像用户本人写的
5. **叙述风格分析** → 整体叙述方式高度个性化

**量化目标：**
- 生成内容的"像用户本人写的"程度：从60%提升到85%+
- 内容吸引力分数：提升20-30%
- 用户满意度：提升至90%+

---

## 🚀 实施计划

### Phase 1：数据库和基础算法（1-2天）
1. 创建/修改数据库表
2. 实现5个分析算法
3. 单元测试

### Phase 2：API和集成（1天）
1. 创建API路由
2. 集成到现有分析流程
3. 测试端到端流程

### Phase 3：内容生成应用（2-3天）
1. 修改 generateOutline 函数
2. 修改 generateContent 函数
3. 添加生成后评估

### Phase 4：前端展示（1-2天）
1. 创建可视化组件
2. 更新风格档案页面
3. 添加分析触发按钮

### Phase 5：测试和优化（1-2天）
1. 端到端测试
2. 性能优化
3. 用户反馈收集

**总预计时间：6-10天**

---

## ✅ 验收标准

1. 数据库正确存储所有进阶特征
2. 分析算法准确识别各项特征
3. 生成的内容明显体现用户风格
4. 前端清晰展示所有分析结果
5. 整体流程稳定可靠

准备开始实施吗？