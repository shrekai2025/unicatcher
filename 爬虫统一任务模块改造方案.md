# 爬虫统一任务模块改造方案

## 改造目标
将现有的Twitter专用爬虫架构改造为支持多平台（Twitter + YouTube）的统一任务管理系统，解决浏览器实例冲突和资源竞争问题。

## 当前架构问题分析

### 1. 现有架构
```
BrowserManager (单例)
    ↓
TaskExecutor (Twitter专用)
    ↓
TwitterSelector
    ↓
StorageService (Twitter表结构)
```

### 2. 主要问题
- **浏览器冲突**：单一BrowserManager无法支持多平台并发
- **任务类型固化**：TaskExecutor硬编码Twitter逻辑
- **选择器耦合**：TwitterSelector与TaskExecutor紧耦合
- **存储服务局限**：StorageService只支持Twitter数据结构

## 改造方案设计

### 1. 新架构设计

```
UnifiedTaskManager (统一任务管理器)
    ↓
TaskType枚举 (TWITTER_LIST | YOUTUBE_CHANNEL)
    ↓
├── TwitterTaskExecutor (继承BaseTaskExecutor)
├── YouTubeTaskExecutor (继承BaseTaskExecutor)
    ↓
├── TwitterBrowserPool (专用浏览器池)
├── YouTubeBrowserPool (专用浏览器池)
    ↓
├── TwitterSelector
├── YouTubeSelector
    ↓
UnifiedStorageService (支持多表)
```

### 2. 核心模块设计

#### 2.1 任务类型定义
```typescript
// src/types/crawler.ts
export enum TaskType {
  TWITTER_LIST = 'twitter_list',
  YOUTUBE_CHANNEL = 'youtube_channel'
}

export interface BaseTaskConfig {
  type: TaskType;
  id?: string;
  priority?: number;
  maxRetries?: number;
}

export interface TwitterTaskConfig extends BaseTaskConfig {
  type: TaskType.TWITTER_LIST;
  listId: string;
  maxTweets?: number;
}

export interface YouTubeTaskConfig extends BaseTaskConfig {
  type: TaskType.YOUTUBE_CHANNEL;
  usernames: string[];
  maxVideosPerChannel?: number;
}

export type TaskConfig = TwitterTaskConfig | YouTubeTaskConfig;
```

#### 2.2 统一任务管理器
```typescript
// src/server/core/crawler/UnifiedTaskManager.ts
export class UnifiedTaskManager {
  private static instance: UnifiedTaskManager;
  private runningTasks: Map<string, BaseTaskExecutor> = new Map();
  private taskQueue: TaskConfig[] = [];
  private maxConcurrentTasks = 2; // 支持Twitter + YouTube并发

  // 提交任务到队列
  async submitTask(config: TaskConfig): Promise<string> {
    const taskId = await this.createTaskRecord(config);
    this.taskQueue.push({ ...config, id: taskId });
    this.processQueue();
    return taskId;
  }

  // 处理任务队列
  private async processQueue(): Promise<void> {
    if (this.runningTasks.size >= this.maxConcurrentTasks) return;

    const nextTask = this.taskQueue.shift();
    if (!nextTask) return;

    const executor = this.createExecutor(nextTask);
    this.runningTasks.set(nextTask.id!, executor);

    // 异步执行
    this.executeTask(nextTask, executor);
  }

  // 创建对应的执行器
  private createExecutor(config: TaskConfig): BaseTaskExecutor {
    switch (config.type) {
      case TaskType.TWITTER_LIST:
        return new TwitterTaskExecutor();
      case TaskType.YOUTUBE_CHANNEL:
        return new YouTubeTaskExecutor();
      default:
        throw new Error(`不支持的任务类型: ${config.type}`);
    }
  }
}
```

#### 2.3 基础任务执行器
```typescript
// src/server/core/crawler/BaseTaskExecutor.ts
export abstract class BaseTaskExecutor {
  protected browserManager?: BrowserManager;
  protected storageService: UnifiedStorageService;
  protected isRunning = false;

  constructor() {
    this.storageService = new UnifiedStorageService();
  }

  // 抽象方法：子类实现具体执行逻辑
  abstract executeTask(config: TaskConfig): Promise<TaskResult>;

  // 通用方法：初始化浏览器
  protected async initializeBrowser(type: TaskType): Promise<void> {
    const browserPool = this.getBrowserPool(type);
    this.browserManager = await browserPool.getBrowser();
  }

  // 获取对应的浏览器池
  private getBrowserPool(type: TaskType): BrowserPool {
    switch (type) {
      case TaskType.TWITTER_LIST:
        return TwitterBrowserPool.getInstance();
      case TaskType.YOUTUBE_CHANNEL:
        return YouTubeBrowserPool.getInstance();
    }
  }

  // 通用清理方法
  protected async cleanup(): Promise<void> {
    if (this.browserManager) {
      // 归还浏览器到池中，而不是直接关闭
      const pool = this.getBrowserPool(this.getTaskType());
      await pool.returnBrowser(this.browserManager);
      this.browserManager = undefined;
    }
  }

  protected abstract getTaskType(): TaskType;
}
```

#### 2.4 浏览器池设计
```typescript
// src/server/core/browser/BrowserPool.ts
export abstract class BrowserPool {
  protected browsers: BrowserManager[] = [];
  protected availableBrowsers: BrowserManager[] = [];
  protected readonly maxPoolSize = 2;

  async getBrowser(): Promise<BrowserManager> {
    // 如果有可用浏览器，直接返回
    if (this.availableBrowsers.length > 0) {
      return this.availableBrowsers.pop()!;
    }

    // 如果池未满，创建新浏览器
    if (this.browsers.length < this.maxPoolSize) {
      const browser = await this.createBrowser();
      this.browsers.push(browser);
      return browser;
    }

    // 等待浏览器可用
    return this.waitForAvailableBrowser();
  }

  async returnBrowser(browser: BrowserManager): Promise<void> {
    const isHealthy = await browser.healthCheck();
    if (isHealthy) {
      this.availableBrowsers.push(browser);
    } else {
      // 不健康的浏览器直接关闭并从池中移除
      await browser.close();
      this.removeBrowserFromPool(browser);
    }
  }

  protected abstract createBrowser(): Promise<BrowserManager>;
}

// Twitter浏览器池
export class TwitterBrowserPool extends BrowserPool {
  private static instance: TwitterBrowserPool;

  protected async createBrowser(): Promise<BrowserManager> {
    const config = {
      headless: config.playwright.headless,
      userAgent: config.spider.userAgent,
      storageStateFile: 'twitter-browser-state.json' // Twitter专用
    };
    return BrowserManager.create(config);
  }

  static getInstance(): TwitterBrowserPool {
    if (!this.instance) {
      this.instance = new TwitterBrowserPool();
    }
    return this.instance;
  }
}

// YouTube浏览器池
export class YouTubeBrowserPool extends BrowserPool {
  private static instance: YouTubeBrowserPool;

  protected async createBrowser(): Promise<BrowserManager> {
    const config = {
      headless: config.playwright.headless,
      userAgent: 'Mozilla/5.0 (compatible; YouTubeBot)', // YouTube专用UA
      storageStateFile: 'youtube-browser-state.json' // YouTube专用
    };
    return BrowserManager.create(config);
  }

  static getInstance(): YouTubeBrowserPool {
    if (!this.instance) {
      this.instance = new YouTubeBrowserPool();
    }
    return this.instance;
  }
}
```

#### 2.5 YouTube任务执行器
```typescript
// src/server/core/crawler/YouTubeTaskExecutor.ts
export class YouTubeTaskExecutor extends BaseTaskExecutor {
  private youtubeSelector?: YouTubeSelector;

  async executeTask(config: YouTubeTaskConfig): Promise<TaskResult> {
    try {
      await this.initializeBrowser(TaskType.YOUTUBE_CHANNEL);

      const page = await this.browserManager!.getPage();
      this.youtubeSelector = new YouTubeSelector(page);

      const result = await this.crawlChannels(config);

      return {
        success: true,
        message: `YouTube爬取完成，共获得 ${result.totalVideos} 个视频`,
        data: result
      };
    } catch (error) {
      return {
        success: false,
        message: `YouTube爬取失败: ${error.message}`,
        error: error
      };
    } finally {
      await this.cleanup();
    }
  }

  private async crawlChannels(config: YouTubeTaskConfig): Promise<any> {
    let totalVideos = 0;

    for (const username of config.usernames) {
      const channelResult = await this.crawlSingleChannel(username);
      totalVideos += channelResult.newVideos;

      // 保存到数据库
      await this.storageService.saveYouTubeVideos(
        channelResult.videos,
        config.id!
      );
    }

    return { totalVideos };
  }

  protected getTaskType(): TaskType {
    return TaskType.YOUTUBE_CHANNEL;
  }
}
```

### 3. 数据存储改造

#### 3.1 统一存储服务
```typescript
// src/server/core/data/UnifiedStorageService.ts
export class UnifiedStorageService {
  // Twitter相关方法 (保持现有接口不变)
  async saveTweets(tweets: TweetData[], taskId: string): Promise<void> {
    // 现有实现保持不变
  }

  // YouTube相关方法 (新增)
  async saveYouTubeVideos(videos: YouTubeVideo[], taskId: string): Promise<void> {
    // 实现YouTube视频保存逻辑
  }

  async checkYouTubeVideoExists(videoId: string): Promise<boolean> {
    // 检查YouTube视频是否已存在
  }

  // 统一任务管理方法
  async createTask(config: TaskConfig): Promise<string> {
    switch (config.type) {
      case TaskType.TWITTER_LIST:
        return this.createTwitterTask(config as TwitterTaskConfig);
      case TaskType.YOUTUBE_CHANNEL:
        return this.createYouTubeTask(config as YouTubeTaskConfig);
    }
  }
}
```

## 改造实施计划

### Phase 1: 基础架构改造 (2-3天)
1. ✅ 创建TaskType枚举和基础接口
2. ✅ 实现BaseTaskExecutor抽象类
3. ✅ 重构TwitterTaskExecutor继承BaseTaskExecutor
4. ✅ 创建UnifiedTaskManager替换现有TaskExecutorManager

### Phase 2: 浏览器池实现 (1-2天)
1. ✅ 创建BrowserPool基类
2. ✅ 实现TwitterBrowserPool和YouTubeBrowserPool
3. ✅ 修改BrowserManager支持配置隔离
4. ✅ 测试浏览器池的创建和回收机制

### Phase 3: YouTube执行器开发 (2-3天)
1. ✅ 创建YouTubeTaskExecutor
2. ✅ 实现YouTubeSelector
3. ✅ 扩展UnifiedStorageService支持YouTube数据
4. ✅ 集成到UnifiedTaskManager

### Phase 4: 系统集成测试 (1天)
1. ✅ Twitter和YouTube任务并发测试
2. ✅ 浏览器资源竞争测试
3. ✅ 错误恢复机制测试
4. ✅ 性能压力测试

## 兼容性保证

### 1. API兼容性
- 现有Twitter API接口保持不变
- 通过UnifiedTaskManager透明代理到TwitterTaskExecutor

### 2. 数据库兼容性
- Twitter相关表结构不变
- 新增YouTube表，互不影响

### 3. 配置兼容性
- 现有config.ts配置项保持不变
- 新增YouTube专用配置节

## 改造后的优势

1. **资源隔离**：Twitter和YouTube使用独立浏览器池，避免状态冲突
2. **并发支持**：可同时运行不同平台任务，提高效率
3. **可扩展性**：后续添加新平台只需实现对应的TaskExecutor
4. **向后兼容**：现有Twitter功能完全不受影响
5. **统一管理**：单一入口管理所有爬虫任务，便于监控和调度

## 风险控制

1. **渐进式改造**：分阶段实施，每个阶段都能回滚
2. **功能开关**：新功能通过配置开关控制，出问题可快速关闭
3. **充分测试**：每个阶段都有完整的测试覆盖
4. **监控告警**：改造过程中加强日志和监控

这个改造方案既解决了现有架构问题，又为未来扩展打下了基础，同时最大程度保证了系统的稳定性和兼容性。